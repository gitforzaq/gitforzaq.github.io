<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Knowledge_Graph</title>
    <url>/artificial-intelligence/Knowledge-Graph/</url>
    <content><![CDATA[<h1 id="知识图谱定义"><a href="#知识图谱定义" class="headerlink" title="知识图谱定义"></a>知识图谱定义</h1><p>知识图谱：是结构化的语义知识库，用于以符号形式描述物理世界中的概念及其相互关系。其基本组成单位是“实体-关系-实体”三元组，以及实体及其相关属性值对，实体间通过关系相互联结，构成网状的知识结构。</p>
<ul>
<li>知识图谱主要目标是用来描述真实世界中存在的各种实体和概念，以及他们之间的强关系。</li>
<li>知识图谱可以通过认为构建与定义，去描述各种概念之间的弱关系。</li>
</ul>
<p>所以，知识图谱，本质上是一种解释实体之间关系的语义网络。<br>知识图谱是由一条条知识组成，每条知识表示为一个SPO三元组(Subject-Predicate-Object)。</p>
<h2 id="构建方法"><a href="#构建方法" class="headerlink" title="构建方法"></a>构建方法</h2><ul>
<li>自顶向下的构建方法(top-down)：<ul>
<li>自顶向下指的是先为知识图谱定义好本体与数据模式，再将实体加入到知识库。</li>
<li>这种构建方式需要利用一些现有的结构坏知识库作为其基础知识库</li>
</ul>
</li>
<li>自底向上的构建方法(bottom-up)：<ul>
<li>自底向上指的是从一些开放链接数据(也就是信息)中提取出实体，选择其中置信度较高的加入到知识库，再构建实体与实体之间的联系。</li>
</ul>
</li>
</ul>
<h2 id="知识图谱的技术架构"><a href="#知识图谱的技术架构" class="headerlink" title="知识图谱的技术架构"></a>知识图谱的技术架构</h2><p><img src="/artificial-intelligence/Knowledge-Graph/knowledge_graph.png" alt="Technical architecture of knowledge graph"></p>
<h2 id="知识图谱的体系结构"><a href="#知识图谱的体系结构" class="headerlink" title="知识图谱的体系结构"></a>知识图谱的体系结构</h2><p><img src="/artificial-intelligence/Knowledge-Graph/knowledge_graph_2.png" alt></p>
<p>知识图谱架构主要的部分有：</p>
<ul>
<li>知识抽取：从一些公开的半结构化、非结构化的数据中提取出实体、关系、属性等知识要素<ul>
<li>实体抽取(NER,命名实体识别)，指的是从原始语料中自动识别出命名实体。由于实体是知识图谱中的最基本元素，其抽取的完整性、准确、召回率等将直接影响到知识库的质量。因此，实体抽取是知识抽取中最为基础与关键的一步；</li>
<li>关系抽取，目标是解决实体间语义链接的问题。早期的关系抽取主要是通过人工构造语义贵州人以及模板的方法识别实体关系。随后，实体间的关系模型逐渐替代了人工预定义的语法与规则；</li>
<li>属性抽取，主要是针对实体而言的，通过属性课形成对实体的完整勾画。由于实体的属性可以看成是实体与属性值之间的一种名称性关系，因此可以将实体属性的抽取问题转换为关系抽取问题。<br><img src="/artificial-intelligence/Knowledge-Graph/knowledge_extraction.png" alt="knowledge_extraction"></li>
</ul>
</li>
<li>知识融合：消除实体、关系、属性等指称项与事实对象之间的歧义，形成高质量的知识库<ul>
<li>实体连接<ul>
<li>实体消岐–专门用于解决同名实体产生歧义问题的技术。</li>
<li>实体对齐–主要用于消除异构数据中实体冲突、指向不明等不一致性问题，可以从顶层创建一个大规模的统一知识库，从而帮助机器理解多源异质的数据，形成高质量的知识库。</li>
<li>实体链接技术也可以从整体层面分类如下：<br><img src="/artificial-intelligence/Knowledge-Graph/connection.png" alt="connection"></li>
</ul>
</li>
<li>知识合并</li>
<li>知识加工</li>
<li>知识更新</li>
<li>知识表示</li>
</ul>
</li>
<li>知识加工：<ul>
<li>知识推理：在已有的知识库基础上进一步挖掘隐含的知识和，从而丰富、扩展知识库<br><img src="/artificial-intelligence/Knowledge-Graph/knowledge_reasoning.png" alt="reasoning"></li>
<li>本体构建</li>
</ul>
</li>
<li>知识表现<ul>
<li>距离模型</li>
<li>单层神经网络</li>
<li>双线性模型</li>
<li>神经张量模型</li>
<li>矩阵分解模型<ul>
<li>RESACL模型</li>
</ul>
</li>
<li>翻译模型<ul>
<li>TransE模型</li>
</ul>
</li>
<li>复杂关系模型：<ul>
<li>知识库中的实体关系类型可分为：<ul>
<li>1-to-1、</li>
<li>1-to-N、</li>
<li>N-to-1、</li>
<li>N-to-N 4种类型。</li>
</ul>
</li>
<li>代表性模型有：<ul>
<li>TransH模型、</li>
<li>TransR模型、</li>
<li>TransD模型、</li>
<li>TransG模型、</li>
<li>KG2E模型。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/artificial-intelligence/Knowledge-Graph/knowledge_representation.png" alt="representation"></p>
]]></content>
      <categories>
        <category>artificial_intelligence</category>
      </categories>
      <tags>
        <tag>knowledge_graph</tag>
      </tags>
  </entry>
  <entry>
    <title>maya</title>
    <url>/maya/maya/</url>
    <content><![CDATA[<h2 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h2><blockquote>
<p>option+B 调整工作界面背景颜色</p>
</blockquote>
<blockquote>
<p>切换四视图：空格</p>
</blockquote>
<blockquote>
<p>长按空格：热盒</p>
</blockquote>
<blockquote>
<p>视觉旋转： command+鼠标拖动（左键、右键、滚轮）</p>
</blockquote>
<blockquote>
<p>缩放：双指触控板上下或左右</p>
</blockquote>
<h2 id="交互式创建"><a href="#交互式创建" class="headerlink" title="交互式创建"></a>交互式创建</h2><p>另一种创建模式。改变模式之后可以拖动式创建物体。</p>
<p>完成时退出：多次创建</p>
<p>细分：command+E</p>
<p>平滑显示：2，3<br>取消：1<br>透明显示： 4， 还原： 5<br>着色显示：6<br>灯光： 7</p>
<p>复制： shift+复制</p>
<p>变形-&gt;非线性-&gt;弯曲<br>结束用option+shift+D</p>
]]></content>
      <categories>
        <category>maya</category>
      </categories>
      <tags>
        <tag>maya</tag>
      </tags>
  </entry>
  <entry>
    <title>BinarySearchTree</title>
    <url>/algorithm/BinarySearchTree/</url>
    <content><![CDATA[<h1 id="二叉普通查找树-BST"><a href="#二叉普通查找树-BST" class="headerlink" title="二叉普通查找树(BST)"></a>二叉普通查找树(BST)</h1><p>普通查找树需要满足的要求：</p>
<ul>
<li>若任意结点的左子树不为空，则左子树上所有结点的值均小于它的根结点的值</li>
<li>若任意结点的右子树不为空，则右子树上搜有结点的值均大于它的根结点的值</li>
<li>任意结点的左、右子树也分别是二叉查找树</li>
<li>没有键值相等的结点</li>
</ul>
<blockquote>
<p>普通的查找树是所有种类的查找树（AVL树，伸展树，红黑树）的超集。它即可能是平衡的，也可能是不平衡的。</p>
</blockquote>
<blockquote>
<p>所以，如果普通查找树 中插入的是有序的数据或者是逆序的数据，该普通树的执行速度会很慢，因为是最不平衡最坏的结果。</p>
</blockquote>
<blockquote>
<p>一颗N结点查找树如果是可变的，那么理论上它的查找时间复杂度必然介于O(logN)~O(N)之间</p>
</blockquote>
<h2 id="二叉查找树增、删、查、改"><a href="#二叉查找树增、删、查、改" class="headerlink" title="二叉查找树增、删、查、改"></a>二叉查找树增、删、查、改</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><h4 id="增删查改"><a href="#增删查改" class="headerlink" title="增删查改"></a>增删查改</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">TreePtr <span class="title">BSTInit</span><span class="params">(ElementType E)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreePtr T = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TreeNode));</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;data = E;</span><br><span class="line">        T-&gt;left = T-&gt;right = NLL;</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    retrn <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> elem;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">leftChild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span>* <span class="title">rightChild</span>;</span></span><br><span class="line">&#125;BitNode, *BinTree;</span><br><span class="line"></span><br><span class="line"><span class="comment">//insert binary tree function</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 插入key值</span></span><br><span class="line"><span class="function">BinTree <span class="title">Insert_BinaryTree</span><span class="params">(BinTree &amp;bt, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="number">0</span>)&#123;</span><br><span class="line">        bt = <span class="keyword">new</span> BitNode;</span><br><span class="line">        bt-&gt;elem = key;</span><br><span class="line">        bt-&gt;leftChild = <span class="number">0</span>;</span><br><span class="line">        bt-&gt;rightChild = <span class="number">0</span></span><br><span class="line">        retrn bt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前要插入的值小于当前结点，向左递归</span></span><br><span class="line">    <span class="keyword">if</span>(key &lt; bt-&gt;elem)&#123;</span><br><span class="line">        bt-&gt;leftChild = Insert_BinaryTree(bt-&gt;leftChild, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前要插入的值大于当前结点，向右递归</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        bt-&gt;rightChild = Insert_BinaryTree(bt-&gt;rightChild, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找，递归方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_BinaryTree</span><span class="params">(BinTree &amp;bt, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(bt-&gt;elem == key) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 如果当前要找的值小于当前结点，向左递归</span></span><br><span class="line">    <span class="keyword">if</span>(key &lt; bt-&gt;elem)&#123;</span><br><span class="line">        <span class="keyword">return</span> search_BinaryTree(bt-&gt;leftChild, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果当前要找的值大于当前结点，向右递归</span></span><br><span class="line">    <span class="keyword">if</span>(key &gt; bt-&gt;elem)&#123;</span><br><span class="line">        <span class="keyword">return</span> search_BinaryTree(bt-&gt;rightChild, key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 查找，非递归方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search_BinaryTree</span><span class="params">(BinTree &amp;bt, <span class="keyword">int</span> key, BitNode** p, BiitNode** pf)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 二叉树指针</span></span><br><span class="line">    *p = bt;</span><br><span class="line">    <span class="comment">// pf为p的父结点</span></span><br><span class="line">    *pf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(*p != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((*p) -&gt; elem == key) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 如果指针指向的元素大于所要查询的值</span></span><br><span class="line">        <span class="comment">// 指针移向左子树，缩小指向的值</span></span><br><span class="line">        <span class="keyword">if</span>((*p) -&gt; elem &gt; key)</span><br><span class="line">        &#123;</span><br><span class="line">            *pf = *p;</span><br><span class="line">            *p = (*p) -&gt; leftChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果指针指向的元素小于所要查询的值</span></span><br><span class="line">        <span class="comment">// 指针指向右子树，增大指向的值</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            *pf = *p;</span><br><span class="line">            *p = (*p) -&gt; rightChild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 删除某个节点,并且把它的子树上移代替它</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Delete_BinaryTree</span><span class="params">(BinTree *bt, <span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BitNode *p = *bt; <span class="comment">//根结点</span></span><br><span class="line">    BitNode *pf = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> findflag;</span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    findflag = search_BinaryTree(*bt, key, &amp;p, &amp;pf); <span class="comment">//找到该删除的结点</span></span><br><span class="line">    <span class="keyword">if</span>(findflag == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// p为叶子结点，删除叶子结点</span></span><br><span class="line">    <span class="keyword">if</span>(p -&gt; leftChild == <span class="number">0</span> &amp;&amp; p -&gt; rightChild == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果查找的树只有一个根结点</span></span><br><span class="line">        <span class="comment">// 删除整个树</span></span><br><span class="line">        <span class="keyword">if</span>(pf == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> bt;</span><br><span class="line">            bt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到的要删除的结点是父节点的右结点</span></span><br><span class="line">        <span class="keyword">if</span>(p == pf-&gt;leftChild)</span><br><span class="line">        &#123;</span><br><span class="line">            pf-&gt;leftChild = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">            p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果找到的要删除的结点是父节点的左结点</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pf-&gt;rightChild = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">            p = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p没有左结点但是有右结点,即只有一个子结点</span></span><br><span class="line">    <span class="keyword">if</span>( p-&gt;leftChild == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 即p为根结点</span></span><br><span class="line">        <span class="keyword">if</span>(pf = <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *bt = p-&gt;rightChild;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p == pf-&gt;leftChild)</span><br><span class="line">        &#123;</span><br><span class="line">            pf-&gt;leftChild = p-&gt;rightChild;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">            reutrn <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            pf-&gt;rightChild = p-&gt;rightChild;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p-&gt;rightChild == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// p没有右结点但是有左结点,即只有一个子结点</span></span><br><span class="line">        <span class="keyword">if</span>(p = p-&gt;leftChild)</span><br><span class="line">        &#123;</span><br><span class="line">            pf-&gt;leftChild = p -&gt; leftChild;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p == p-&gt;rightChild)</span><br><span class="line">        &#123;</span><br><span class="line">            pf-&gt;rightChild = p -&gt; leftChild;</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 删除的结点p含有两个子结点</span></span><br><span class="line">    BitNode *prf = p;</span><br><span class="line">    BItNode *pr = p -&gt; rightChild;</span><br><span class="line">    <span class="keyword">while</span>(pr-&gt;leftChild != <span class="number">0</span>)&#123;</span><br><span class="line">        prf = pr;</span><br><span class="line">        pr = pr-&gt;leftChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(prf == p)</span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;elem = pr-&gt;elem;</span><br><span class="line">        prf-&gt;rightChild = pr-&gt;rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;elem = pr-&gt;elem;</span><br><span class="line">        prf-&gt;LefttChild = pr-&gt;rightChild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> pr;</span><br><span class="line">    reuturn <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="队列遍历"><a href="#队列遍历" class="headerlink" title="队列遍历"></a>队列遍历</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">(BitNode *ptr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;BitNode*&gt; rel;</span><br><span class="line">    rel.push(ptr);</span><br><span class="line">    <span class="keyword">while</span>(!rel.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        BSPtr *front = rel.front();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, front-&gt;data);</span><br><span class="line">        rel.pop();</span><br><span class="line">        <span class="keyword">if</span>(front)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(front-&gt;left != null) rel.push(front-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(front-&gt;right != null) rel.push(front-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="哈夫曼树（HUffman-Tree）"><a href="#哈夫曼树（HUffman-Tree）" class="headerlink" title="哈夫曼树（HUffman Tree）"></a>哈夫曼树（HUffman Tree）</h1><p>哈夫曼树让连接各个结点的路径带权，对于一组给定的数据，总存在唯一的让所有带权路径之和最小的树形结构，我们称这样的树为关于这一组给定数据的哈夫曼树；</p>
<p>通常处理的数据数目庞大以至于不可能完全统计，通常使用概率代替频率作为描述特定数据集合的哈夫曼树的权值</p>
<blockquote>
<p>哈夫曼树并不满足一般查找树“左孩子比父结点大，右孩子比父结点小”的特点，从这一点看哈夫曼树不是严格的查找树——但是考虑到它可以查找数据的功能，姑且认为它也是一种特殊的查找树（静态的查找树，只能进行查找通常不做数据的修改、添加等操作）</p>
</blockquote>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>search_algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>chrome.tabs</title>
    <url>/chrome/chrome-tabs/</url>
    <content><![CDATA[<h1 id="chrome-tabs"><a href="#chrome-tabs" class="headerlink" title="chrome.tabs"></a>chrome.tabs</h1><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>使用chrome.tabs API与浏览器的标签页系统交互，使用该API可以创建，修改和重新排列浏览器中的标签页。</p>
<h2 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h2><p>如果您需要访问Tab的url、title或者favIconUrl属性，则必须在manifest文件中声明“tabs”权限：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"permissions"</span>: [</span><br><span class="line">        <span class="string">"tabs"</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><h3 id="id-integer"><a href="#id-integer" class="headerlink" title="id(integer)"></a>id(integer)</h3><p>标签页的标识符。标签页的标识符在浏览器会话中唯一。在某些情况下，标签页可能没有标识符，例如使用 sessions API 查询外来标签页时，此时可能存在会话标识符。</p>
<h3 id="index-integer"><a href="#index-integer" class="headerlink" title="index(integer)"></a>index(integer)</h3><p>标签页在所在窗口中的索引，从 0 开始。</p>
<h3 id="windowId-integer"><a href="#windowId-integer" class="headerlink" title="windowId(integer)"></a>windowId(integer)</h3><p>标签页所在窗口的标识符。</p>
<h3 id="openerTabId-optional-integer"><a href="#openerTabId-optional-integer" class="headerlink" title="openerTabId(optional integer)"></a>openerTabId(optional integer)</h3><p>打开这一标签页的标签页标识符（如果存在的话），只有该标签页仍然存在时才会有这一属性。</p>
<h3 id="highlighted-boolean"><a href="#highlighted-boolean" class="headerlink" title="highlighted(boolean)"></a>highlighted(boolean)</h3><p>标签页是否高亮突出。</p>
<h3 id="active-boolean"><a href="#active-boolean" class="headerlink" title="active(boolean)"></a>active(boolean)</h3><p>标签页是否是窗口中的活动标签页。（窗口不一定有焦点。）</p>
<h3 id="pinned-boolean"><a href="#pinned-boolean" class="headerlink" title="pinned(boolean)"></a>pinned(boolean)</h3><p>标签页是否固定。</p>
<h3 id="url-optional-string"><a href="#url-optional-string" class="headerlink" title="url(optional string)"></a>url(optional string)</h3><p>标签页中显示的 URL，只有当扩展程序拥有 “tabs” 权限时该属性才会存在。</p>
<h3 id="title-optional-string"><a href="#title-optional-string" class="headerlink" title="title(optional string)"></a>title(optional string)</h3><p>标签页的标题，只有当扩展程序拥有 “tabs” 权限时该属性才会存在，如果标签页正在加载它也可能是空字符串。</p>
<h3 id="favIconUrl-optional-string"><a href="#favIconUrl-optional-string" class="headerlink" title="favIconUrl(optional string)"></a>favIconUrl(optional string)</h3><p>标签页的收藏夹图标 URL，只有当扩展程序拥有 “tabs” 权限时该属性才会存在，如果标签页正在加载它也可能是空字符串。</p>
<h3 id="status-optional-string"><a href="#status-optional-string" class="headerlink" title="status(optional string)"></a>status(optional string)</h3><p>“loading”（正在加载）或 “complete”（完成）。</p>
<h3 id="incognito-boolean"><a href="#incognito-boolean" class="headerlink" title="incognito(boolean)"></a>incognito(boolean)</h3><p>标签页是否在隐身窗口中。</p>
<h3 id="width-optional-integer"><a href="#width-optional-integer" class="headerlink" title="width(optional integer)"></a>width(optional integer)</h3><p>标签页宽度，以像素为单位。</p>
<h3 id="height-optional-integer"><a href="#height-optional-integer" class="headerlink" title="height(optional integer)"></a>height(optional integer)</h3><p>标签页高度，以像素为单位。</p>
<h3 id="sessionId-optional-string"><a href="#sessionId-optional-string" class="headerlink" title="sessionId(optional string)"></a>sessionId(optional string)</h3><p>会话标识符，用于唯一标识由 sessions API 获取的标签页。</p>
<h2 id="InjectDetails"><a href="#InjectDetails" class="headerlink" title="InjectDetails"></a>InjectDetails</h2><p>表示要插入的脚本或者CSS的详情，必须设置code和file属性中的某一个，而且不能同时设置。</p>
<h3 id="code-optional-string"><a href="#code-optional-string" class="headerlink" title="code(optional string)"></a>code(optional string)</h3><p>要插入的 JavaScript 或 CSS 代码。</p>
<h3 id="file-optional-string"><a href="#file-optional-string" class="headerlink" title="file(optional string)"></a>file(optional string)</h3><p>要插入的 JavaScript 或 CSS 文件。</p>
<h3 id="allFrames-optional-boolean"><a href="#allFrames-optional-boolean" class="headerlink" title="allFrames(optional boolean)"></a>allFrames(optional boolean)</h3><p>如果 allFrames 为 true，则意味着当前页面中的所有框架都要插入 JavaScript 或 CSS。默认情况下为 false，只在顶层主框架中插入。</p>
<h3 id="runAt-optional-enum-of-“document-start”-”document-end”-or-“document-idle”"><a href="#runAt-optional-enum-of-“document-start”-”document-end”-or-“document-idle”" class="headerlink" title="runAt(optional enum of “document_start”,”document_end” or “document_idle”)"></a>runAt(optional enum of “document_start”,”document_end” or “document_idle”)</h3><p>JavaScript 或 CSS 插入标签页的最早时间，默认为 “document_idle”。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><blockquote>
<p>chrome.tabs.get(integer tabId, function callback)<br>获得指定标签页的有关详情。</p>
</blockquote>
<p><strong>参数</strong></p>
<ul>
<li><p>tabId ( integer )</p>
</li>
<li><p>callback ( function )</p>
</li>
</ul>
<p>callback 参数应该指定一个如下形式的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(Tab tab) &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>tab ( Tab )</p>
<h3 id="getCurrent"><a href="#getCurrent" class="headerlink" title="getCurrent"></a>getCurrent</h3><blockquote>
<p>chrome.tabs.getCurrent(function callback)<br>获得当前调用脚本所在的标签页，如果在非标签页环境下调用则可能返回 undefined（例如，后台页面或弹出视图）。</p>
</blockquote>
<p><strong>参数</strong></p>
<ul>
<li>callback ( function )</li>
</ul>
<p>callback 参数应该指定一个如下形式的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(Tab tab) &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>tab ( optional Tab )</p>
<h3 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h3><blockquote>
<p>runtime.Port chrome.tabs.connect(integer tabId, object connectInfo)<br>连接到指定标签页中的内容脚本，这样当前扩展程序在指定标签页中运行的每一个内容脚本都会产生 runtime.onConnect 事件。有关更多详情，请参见内容脚本的消息传递。</p>
</blockquote>
<p><strong>参数</strong></p>
<ul>
<li><p>tabId ( integer )</p>
</li>
<li><p>connectInfo ( optional object )</p>
<ul>
<li><p><strong>属性</strong></p>
<p>  name ( optional string )</p>
<p>  将传递给 onConnect 事件，用于监听连接事件的内容脚本。</p>
</li>
</ul>
</li>
</ul>
<h3 id="sendMessage"><a href="#sendMessage" class="headerlink" title="sendMessage"></a>sendMessage</h3><blockquote>
<p>chrome.tabs.sendMessage(integer tabId, any message, function responseCallback)<br>向指定标签页中的内容脚本发送一个消息，当发回响应时执行一个可选的回调函数。当前扩展程序在指定标签页中的每一个内容脚本都会收到 runtime.onMessage 事件。</p>
</blockquote>
<p><strong>参数</strong></p>
<ul>
<li><p>tabId ( integer )</p>
</li>
<li><p>message ( any )</p>
</li>
<li><p>responseCallback ( optional function )</p>
</li>
</ul>
<p>如果您指定了 responseCallback 参数，它应该指定一个如下形式的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(any response) &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>response ( any )</p>
<p>请求处理程序发出的 JSON 响应对象。如果连接到指定标签页的过程中发生错误，将不传递参数调用回调函数，并将 runtime.lastError 设置为错误消息。</p>
<h3 id="sendRequest"><a href="#sendRequest" class="headerlink" title="sendRequest"></a>sendRequest</h3><p>sendRequest 已弃用。请使用 runtime.sendMessage。</p>
<h3 id="getSelected"><a href="#getSelected" class="headerlink" title="getSelected"></a>getSelected</h3><p>getSelected 已弃用。请使用 query {active: true}。</p>
<h3 id="getAllInWindow"><a href="#getAllInWindow" class="headerlink" title="getAllInWindow"></a>getAllInWindow</h3><p>getAllInWindow 已弃用。请使用 query {windowId: windowId}。</p>
<h3 id="create"><a href="#create" class="headerlink" title="create"></a>create</h3><blockquote>
<p>chrome.tabs.create(object createProperties, function callback)<br>创建一个新标签页。</p>
</blockquote>
<p><strong>参数</strong></p>
<ul>
<li><p>createProperties ( object )</p>
<ul>
<li><p>属性</p>
<ul>
<li><p>windowId ( optional integer )</p>
<p>  创建新标签页的窗口，默认为当前窗口。</p>
</li>
<li><p>index ( optional integer )</p>
<p>  标签页在窗口中的位置，提供的值如果超过0与窗口中标签页数目之间的范围，将会自动限定在这一范围。</p>
</li>
<li><p>url ( optional string )</p>
<p>  标签页中一开始打开的 URL。完整的 URL 必须包括协议（即 “<a href="http://www.google.com&quot;，而不能是" target="_blank" rel="noopener">http://www.google.com&quot;，而不能是</a> “<a href="http://www.google.com&quot;），相对" target="_blank" rel="noopener">www.google.com&quot;），相对</a> URL 相对于扩展程序中的当前页面。默认为“打开新的标签页”页面。</p>
</li>
<li><p>active ( optional boolean )</p>
<p>  标签页是否应该成为窗口中的活动标签页，不影响窗口是否有焦点（参见 windows.update），默认为 true。</p>
</li>
<li><p>selected ( optional boolean )</p>
<p>  selected 已弃用。请使用 active。<br>  标签页是否为窗口中的选定标签页，默认为 true。</p>
</li>
<li><p>pinned ( optional boolean )</p>
<p>  标签页是否应该固定，默认为 false。</p>
</li>
<li><p>openerTabId ( optional integer )</p>
<p>  打开这一标签页的标签页标识符。如果指定的话，该标签页必须与新创建的标签页在同一个窗口中。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>callback ( optional function )</p>
<p>  如果您指定了 callback 参数，它应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(Tab tab) &#123;...&#125;;</span><br></pre></td></tr></table></figure>

<p>  tab ( Tab )</p>
<pre><code>有关新创建标签页的详情，会包含新标签页的标识符。</code></pre></li>
</ul>
<h3 id="duplicate"><a href="#duplicate" class="headerlink" title="duplicate"></a>duplicate</h3><blockquote>
<p>chrome.tabs.duplicate(integer tabId, function callback)<br>复制标签页。</p>
</blockquote>
<p><strong>参数</strong></p>
<ul>
<li><p>tabId ( integer )</p>
<p>  要复制的标签页的标识符。</p>
</li>
<li><p>callback ( optional function )</p>
<p>  如果您指定了 callback 参数，它应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(Tab tab) &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>  tab ( optional Tab )</p>
<pre><code>有关已复制标签页的详情，如果没有请求 &quot;tabs&quot; 权限的话 Tab 对象不会包含 url、title 和 favIconUrl。</code></pre></li>
</ul>
<h3 id="query"><a href="#query" class="headerlink" title="query"></a>query</h3><blockquote>
<p>chrome.tabs.query(object queryInfo, function callback)<br>获取具有指定属性的所有标签页，如果没有指定任何属性的话则获取所有标签页。</p>
</blockquote>
<p><strong>参数</strong></p>
<ul>
<li><p>queryInfo ( object )</p>
<ul>
<li><p>属性</p>
<ul>
<li><p>active ( optional boolean )</p>
<p>  标签页在窗口中是否为活动标签页。</p>
</li>
<li><p>pinned ( optional boolean )</p>
<p>  标签页是否固定。</p>
</li>
<li><p>highlighted ( optional boolean )</p>
<p>  标签页是否高亮突出。</p>
</li>
<li><p>currentWindow ( optional boolean )</p>
<p>  标签页是否在当前窗口中。</p>
</li>
<li><p>lastFocusedWindow ( optional boolean )</p>
<p>  标签页是否在前一个具有焦点的窗口中。</p>
</li>
<li><p>status ( optional enum of “loading”, or “complete” )</p>
<p>  标签页是否已经加载完成。</p>
</li>
<li><p>title ( optional string )</p>
<p>  匹配页面标题的表达式。</p>
</li>
<li><p>url ( optional string )</p>
<p>  匹配标签页的 URL 表达式。注意：片段标识符不会匹配。</p>
</li>
<li><p>windowId ( optional integer )</p>
<p>  父窗口标识符，或者为 windows.WINDOW_ID_CURRENT，表示当前窗口。</p>
</li>
<li><p>windowType ( optional enum of “normal”, “popup”, “panel”, or “app” )</p>
<p>  标签页所在窗口的类型。</p>
</li>
<li><p>index ( optional integer )</p>
<p>  标签页在窗口中的位置。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>callback ( function )</p>
<p>  callback 参数应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(array of Tab result) &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>  result ( array of Tab )</p>
</li>
</ul>
<h3 id="highlight"><a href="#highlight" class="headerlink" title="highlight"></a>highlight</h3><blockquote>
<p>chrome.tabs.highlight(object highlightInfo, function callback)<br>高亮突出指定标签页。</p>
</blockquote>
<p><strong>参数</strong></p>
<ul>
<li><p>highlightInfo ( object )</p>
<ul>
<li><p>属性</p>
<ul>
<li><p>windowId ( optional integer )</p>
<p>  包含标签页的窗口。</p>
</li>
<li><p>tabs ( array of integer or integer )</p>
<p>  要高亮突出的一个或多个标签页的索引。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>callback ( function )</p>
<p>  callback 参数应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(windows.Window window) &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>  window ( windows.Window )</p>
<pre><code>包含高亮突出的标签页所在窗口的详情。</code></pre></li>
</ul>
<h3 id="update"><a href="#update" class="headerlink" title="update"></a>update</h3><blockquote>
<p>chrome.tabs.update(integer tabId, object updateProperties, function callback)<br>修改标签页属性，updateProperties 中未指定的属性保持不变。</p>
</blockquote>
<p><strong>参数</strong></p>
<ul>
<li><p>tabId ( optional integer )</p>
<p>  默认为当前窗口的选定标签页。</p>
</li>
<li><p>updateProperties ( object )</p>
<ul>
<li><p><strong>属性</strong></p>
<ul>
<li><p>url ( optional string )</p>
<p>  标签页打开的 URL。</p>
</li>
<li><p>active ( optional boolean )</p>
<p>  标签页是否为活动标签页，不影响窗口是否有焦点（参见 windows.update）。</p>
</li>
<li><p>highlighted ( optional boolean )</p>
<p>  从当前选定项目中添加或删除标签页。</p>
</li>
<li><p>selected ( optional boolean )</p>
<p>  selected 已弃用。请使用 highlighted。</p>
</li>
<li><p>pinned ( optional boolean )</p>
<p>  标签页是否固定。</p>
</li>
<li><p>openerTabId ( optional integer )</p>
<p>  打开这一标签页的标签页标识符。如果指定的话，该标签页必须与新创建的标签页在同一个窗口中。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>callback ( optional function )</p>
<p>  如果您指定了 callback 参数，它应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(Tab tab) &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>  tab ( optional Tab )</p>
<pre><code>有关更新后的标签页详情，如果没有请求 &quot;tabs&quot; 权限的话 Tab 对象不包含 url、title 和 favIconUrl。</code></pre></li>
</ul>
<h3 id="move"><a href="#move" class="headerlink" title="move"></a>move</h3><blockquote>
<p>chrome.tabs.move(integer or array of integer tabIds, object moveProperties, function callback)<br>将一个或多个标签页移动至所在窗口中的新位置，或者移动到新窗口中。注意，标签页只能在普通窗口（window.type === “normal”）间移动。</p>
</blockquote>
<p><strong>参数</strong></p>
<ul>
<li><p>tabIds ( integer or array of integer )</p>
<p>  要移动的标签页或标签页列表。</p>
</li>
<li><p>moveProperties ( object )</p>
<ul>
<li><p>属性</p>
<ul>
<li><p>windowId ( optional integer )</p>
<p>  默认为该标签页所在窗口。</p>
</li>
<li><p>index ( integer )</p>
<p>  标签页在窗口中的新位置，传递 -1 将会把标签页排在窗口的最后。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>callback ( optional function )</p>
<p>  如果您指定了 callback 参数，它应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(Tab or array of Tab tabs) &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>  tabs ( Tab or array of Tab )<br>  有关移动后标签页的详情。</p>
</li>
</ul>
<h3 id="reload"><a href="#reload" class="headerlink" title="reload"></a>reload</h3><blockquote>
<p>chrome.tabs.reload(integer tabId, object reloadProperties, function callback)<br>重新加载标签页。</p>
</blockquote>
<p><strong>参数</strong></p>
<ul>
<li><p>tabId ( optional integer )</p>
<p>  要重新加载的标签页标识符，默认为当前窗口的选定标签页。</p>
</li>
<li><p>reloadProperties ( optional object )</p>
<ul>
<li><p>属性</p>
<ul>
<li><p>bypassCache ( optional boolean )</p>
<p>  是否使用本地缓存，默认为 false。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>callback ( optional function )</p>
<p>  如果您指定了 callback 参数，它应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function() &#123;...&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><blockquote>
<p>chrome.tabs.remove(integer or array of integer tabIds, function callback)<br>关闭一个或多个标签页。</p>
</blockquote>
<p><strong>参数</strong></p>
<ul>
<li><p>tabIds ( integer or array of integer )</p>
<p>  要关闭的标签页或标签页列表。</p>
</li>
<li><p>callback ( optional function )</p>
<p>  如果您指定了 callback 参数，它应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function() &#123;...&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="detectLanguage"><a href="#detectLanguage" class="headerlink" title="detectLanguage"></a>detectLanguage</h3><blockquote>
<p>chrome.tabs.detectLanguage(integer tabId, function callback)<br>检测某个标签页中内容的主要语言。</p>
</blockquote>
<p><strong>参数</strong></p>
<ul>
<li><p>tabId ( optional integer )</p>
<p>  默认为当前窗口的活动标签页。</p>
</li>
<li><p>callback ( function )</p>
<p>  callback 参数应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(string language) &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>  language ( string )</p>
<p>  ISO 语言代码，例如 en 或 fr。有关该方法支持的所有语言的完整列表，请参见 kLanguageInfoTable，将检查第二列到第四列并返回第一个非 NULL 值（除了简体中文返回 zh-CN），未知语言将返回 und。</p>
</li>
</ul>
<h3 id="captureVisibleTab"><a href="#captureVisibleTab" class="headerlink" title="captureVisibleTab"></a>captureVisibleTab</h3><blockquote>
<p>chrome.tabs.captureVisibleTab(integer windowId, types.ImageDetails options, function callback)<br>捕捉指定窗口中当前活动标签页的可见区域，您必须拥有标签页中打开的 URL 的主机权限。</p>
</blockquote>
<p><strong>参数</strong></p>
<ul>
<li><p>windowId ( optional integer )</p>
<p>  目标窗口，默认为当前窗口。</p>
</li>
<li><p>options ( optional types.ImageDetails )</p>
</li>
<li><p>callback ( function )</p>
<p>  callback 参数应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(string dataUrl) &#123;...&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>dataUrl ( string )</p>
<p>  包含捕捉到的标签页可视区域图像的数据URL，可以将一个 HTML 图像元素的 “src” 属性设为该参数的值来显示图像。</p>
</li>
</ul>
<h3 id="executeScript"><a href="#executeScript" class="headerlink" title="executeScript"></a>executeScript</h3><blockquote>
<p>chrome.tabs.executeScript(integer tabId, InjectDetails details, function callback)<br>在页面中插入 JavaScript 代码。有关更多详情，请参节内容脚本文档中以编程方式插入部分。</p>
</blockquote>
<p><strong>参数</strong></p>
<ul>
<li><p>tabId ( optional integer )</p>
<p>  运行脚本的标签页标识符，默认为当前窗口的活动标签页。</p>
</li>
<li><p>details ( InjectDetails )</p>
<p>  需要运行的脚本详情。</p>
</li>
<li><p>callback ( optional function )</p>
<p>  在所有 JavaScript 代码执行完后调用。<br>  如果您指定了 callback 参数，它应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(array of any result) &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>  result ( optional array of any )</p>
<p>  在插入的每一个框架中脚本的执行结果。</p>
</li>
</ul>
<h3 id="insertCSS"><a href="#insertCSS" class="headerlink" title="insertCSS"></a>insertCSS</h3><blockquote>
<p>chrome.tabs.insertCSS(integer tabId, InjectDetails details, function callback)<br>向一个页面中插入CSS。有关更多详情，请参节内容脚本文档中以编程方式插入部分。</p>
</blockquote>
<p><strong>参数</strong></p>
<ul>
<li><p>tabId ( optional integer )</p>
<p>  要插入CSS的标签页标识符，默认为当前窗口的活动标签页。</p>
</li>
<li><p>details ( InjectDetails )</p>
<p>  要插入的CSS文本详情。</p>
</li>
<li><p>callback ( optional function )</p>
<p>  当所有CSS都已经被插入后调用。<br>  如果您指定了 callback 参数，它应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function() &#123;...&#125;;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><h3 id="onCreated"><a href="#onCreated" class="headerlink" title="onCreated"></a>onCreated</h3><p>当标签页创建时产生。注意，当该事件发生时标签页的 URL 可能还没有设置，但是您可以处理 onUpdated 事件，在设置 URL 时收到通知。</p>
<ul>
<li>addListener</li>
</ul>
<blockquote>
<p>chrome.tabs.onCreated.addListener(function callback)</p>
</blockquote>
<ul>
<li><p>参数</p>
<ul>
<li><p>callback ( function )</p>
<p>  callback 参数应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(Tab tab) &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<p>  tab ( Tab )</p>
<p>  有关已创建标签页的详情。</p>
</li>
</ul>
</li>
</ul>
<h3 id="onUpdated"><a href="#onUpdated" class="headerlink" title="onUpdated"></a>onUpdated</h3><p>当标签页更新时产生。</p>
<ul>
<li>addListener</li>
</ul>
<blockquote>
<p>chrome.tabs.onUpdated.addListener(function callback)</p>
</blockquote>
<ul>
<li><p>参数</p>
<ul>
<li><p>callback ( function )</p>
<p>  callback 参数应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(integer tabId, object changeInfo, Tab tab) &#123;...&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>tabId ( integer )</p>
</li>
<li><p>changeInfo ( object )</p>
<p>  列出更新的标签页改变的状态。</p>
<p>  属性</p>
<ul>
<li><p>status ( optional string )</p>
<p>  标签页的状态，可以为 loading（正在加载）或 complete（完成）。</p>
</li>
<li><p>url ( optional string )</p>
<p>  标签页的 URL（如果已更改的话）。</p>
</li>
<li><p>pinned ( optional boolean )</p>
<p>  标签页新的固定状态。</p>
</li>
<li><p>favIconUrl ( optional string )</p>
<p>  标签页新的收藏夹图标 URL。</p>
</li>
</ul>
</li>
<li><p>tab ( Tab )</p>
<p>  给出更新后的标签页状态。</p>
</li>
</ul>
</li>
</ul>
<h3 id="onMoved"><a href="#onMoved" class="headerlink" title="onMoved"></a>onMoved</h3><p>当标签页在窗口中移动时产生。仅产生一次移动事件，代表用户的直接移动，其他标签页因此而随之移动并不产生此事件。当标签页在窗口间移动时不产生此事件，在这种情况下，请参见 onDetached。</p>
<ul>
<li>addListener</li>
</ul>
<blockquote>
<p>chrome.tabs.onMoved.addListener(function callback)</p>
</blockquote>
<ul>
<li><p>参数</p>
<ul>
<li><p>callback ( function )</p>
<p>  callback 参数应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(integer tabId, object moveInfo) &#123;...&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>tabId ( integer )</p>
</li>
<li><p>moveInfo ( object )</p>
<ul>
<li><p>属性</p>
<ul>
<li><p>windowId ( integer )</p>
</li>
<li><p>fromIndex ( integer )</p>
</li>
<li><p>toIndex ( integer )</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="onSelectionChanged"><a href="#onSelectionChanged" class="headerlink" title="onSelectionChanged"></a>onSelectionChanged</h3><p>onSelectionChanged 已弃用。请使用 onActivated。</p>
<h3 id="onActiveChanged"><a href="#onActiveChanged" class="headerlink" title="onActiveChanged"></a>onActiveChanged</h3><p>onActiveChanged 已弃用。请使用 onActivated。</p>
<h3 id="onActivated"><a href="#onActivated" class="headerlink" title="onActivated"></a>onActivated</h3><p>当窗口中的当前标签页更改时产生。注意，当该事件发生时标签页的 URL 可能还没有设置，但是您可以处理 onUpdated 事件，在设置 URL 时收到通知。</p>
<ul>
<li>addListener</li>
</ul>
<blockquote>
<p>chrome.tabs.onActivated.addListener(function callback)</p>
</blockquote>
<ul>
<li><p>参数</p>
<ul>
<li><p>callback ( function )</p>
<p>  callback 参数应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(object activeInfo) &#123;...&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>activeInfo ( object )</p>
<ul>
<li><p>属性</p>
<ul>
<li><p>tabId ( integer )</p>
<p>  现在的活动标签页标识符。</p>
</li>
<li><p>windowId ( integer )</p>
<p>  活动标签页更改的窗口标识符。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="onHighlightChanged"><a href="#onHighlightChanged" class="headerlink" title="onHighlightChanged"></a>onHighlightChanged</h3><p>onHighlightChanged 已弃用。请使用 onHighlighted。</p>
<h3 id="onHighlighted"><a href="#onHighlighted" class="headerlink" title="onHighlighted"></a>onHighlighted</h3><p>当窗口中的高亮或选定标签页更改时产生。</p>
<ul>
<li>addListener</li>
</ul>
<blockquote>
<p>chrome.tabs.onHighlighted.addListener(function callback)</p>
</blockquote>
<ul>
<li><p>参数</p>
<ul>
<li><p>callback ( function )</p>
<p>  callback 参数应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(object highlightInfo) &#123;...&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>highlightInfo ( object )</p>
<ul>
<li><p>属性</p>
<ul>
<li><p>windowId ( integer )</p>
<p>  标签页改变的窗口。</p>
</li>
<li><p>tabIds ( array of integer )</p>
<p>  窗口中的所有高亮标签页。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="onDetached"><a href="#onDetached" class="headerlink" title="onDetached"></a>onDetached</h3><p>当标签页从一个窗口中脱离时产生，例如当它在窗口间移动时。</p>
<ul>
<li>addListener</li>
</ul>
<blockquote>
<p>chrome.tabs.onDetached.addListener(function callback)</p>
</blockquote>
<ul>
<li><p>参数</p>
<ul>
<li><p>callback ( function )</p>
<p>  callback 参数应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(integer tabId, object detachInfo) &#123;...&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>tabId ( integer )</p>
</li>
<li><p>detachInfo ( object )</p>
<ul>
<li><p>属性</p>
<ul>
<li><p>oldWindowId ( integer )</p>
</li>
<li><p>oldPosition ( integer )</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="onAttached"><a href="#onAttached" class="headerlink" title="onAttached"></a>onAttached</h3><p>当标签页附加到一个窗口时产生，例如当它在窗口间移动时。</p>
<ul>
<li>addListener</li>
</ul>
<blockquote>
<p>chrome.tabs.onAttached.addListener(function callback)</p>
</blockquote>
<ul>
<li><p>参数</p>
<ul>
<li><p>callback ( function )</p>
<p>  callback 参数应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(integer tabId, object attachInfo) &#123;...&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>tabId ( integer )</p>
</li>
<li><p>attachInfo ( object )</p>
<ul>
<li><p>属性</p>
<ul>
<li><p>newWindowId ( integer )</p>
</li>
<li><p>newPosition ( integer )</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="onRemoved"><a href="#onRemoved" class="headerlink" title="onRemoved"></a>onRemoved</h3><p>当标签页关闭时产生。</p>
<ul>
<li>addListener</li>
</ul>
<blockquote>
<p>chrome.tabs.onRemoved.addListener(function callback)</p>
</blockquote>
<ul>
<li><p>参数</p>
<ul>
<li><p>callback ( function )</p>
<p>  callback 参数应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(integer tabId, object removeInfo) &#123;...&#125;;</span><br></pre></td></tr></table></figure></li>
<li><p>tabId ( integer )</p>
</li>
<li><p>removeInfo ( object )</p>
<ul>
<li><p>属性</p>
<ul>
<li><p>windowId ( integer )</p>
<p>  包含已关闭标签页的窗口。</p>
</li>
<li><p>isWindowClosing ( boolean )</p>
<p>  当标签页因为窗口关闭而关闭时为 true。</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="onReplaced"><a href="#onReplaced" class="headerlink" title="onReplaced"></a>onReplaced</h3><p>当标签页由于预呈现或即搜即得而被另一个标签页替换时产生。</p>
<ul>
<li>addListener</li>
</ul>
<blockquote>
<p>chrome.tabs.onReplaced.addListener(function callback)<br>参数</p>
</blockquote>
<ul>
<li><p>callback ( function )</p>
<p>  callback 参数应该指定一个如下形式的函数：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(integer addedTabId, integer removedTabId) &#123;...&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>addedTabId ( integer )</p>
</li>
<li><p>removedTabId ( integer )</p>
</li>
</ul>
]]></content>
      <categories>
        <category>chrome</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>InsertSort</title>
    <url>/algorithm/binarySort/</url>
    <content><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入算法主要的实现思想，就是将数据按照一定的顺序一个一个的插入到有序的表中，最终得到的序列就是已经排序好的数据。</p>
<p>插入排序算法除了直接插入算法，还包括折半插入排序算法，2-路插入排序算法，表插入排序算法和希尔排序算法等。</p>
<h2 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h2><p>直接插入采用的方法是：在添加新的记录时，使用顺序查找的方法找到其要插入的位置，然后将新记录插入。</p>
<h3 id="执行步骤"><a href="#执行步骤" class="headerlink" title="执行步骤"></a>执行步骤</h3><ul>
<li>首先，待排序的数列由两部分组成，一部分是已经拍好序的部分，另一部分是待排序的部分。有序表在前面，无序表在后面</li>
<li>取待排序的部分的第一个元素，分别与前面的元素进行比较。<ul>
<li>如果大于前面的元素时，可以直接进入已经排好序的部分</li>
<li>如果小于前面的元素，则拿出这个元素，将前面的元素后移一位，继续比较，直到出现一个元素小于这个元素，将这个元素放在空位上</li>
<li>重复步骤2，直到待排序部分已经没有元素可以进行插入时，停止操作。</li>
</ul>
</li>
</ul>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InserSort</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">5</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        Insert_sort(array);</span><br><span class="line">        print(array);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Insert_sort</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = array.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = array[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; array[j - <span class="number">1</span>] &gt; temp; j--)&#123;</span><br><span class="line">                array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            array[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> array[])</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)&#123;</span><br><span class="line">            System.out.print(array[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂素与空间复杂度"><a href="#时间复杂素与空间复杂度" class="headerlink" title="时间复杂素与空间复杂度"></a>时间复杂素与空间复杂度</h3><p>由上述直接插入排序实例可以看出，插入排序在数列近似于有序时，效率会比较高，因为这样会减少比较和移动的次数。</p>
<p>在最坏的情况下，双层嵌套循环内外都要运行n遍，直接插入排序的时间复杂度是O(n^2)<br>在最好的情况下，即序列已经有序，那么直接插入排序的时间复杂度为O(n)</p>
<p>直接插入排序的空间复杂度是O(1)</p>
<p>最后，插入排序是稳定的，数据的相对位置顺序不变</p>
<h2 id="折半插入排序"><a href="#折半插入排序" class="headerlink" title="折半插入排序"></a>折半插入排序</h2><p>由上述的描述可以看出，直接插入排序在找插入位置时，采用的是顺序查找的方法，那么，可以用折半查找的方法代替顺序查找，进而对算法进行优化。</p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Binary_insert_sort</span><span class="params">(<span class="keyword">int</span> array[], <span class="keyword">int</span> size)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>, high = <span class="number">0</span>, mid;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; i++)&#123;</span><br><span class="line">        low = <span class="number">0</span>;</span><br><span class="line">        high = i - <span class="number">1</span>;</span><br><span class="line">        temp = array[i];</span><br><span class="line">        <span class="comment">// 使用折半查找判断插入位置，最终的low表示插入的位置</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt;= high)&#123;</span><br><span class="line">            mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(a[mid] &gt; temp)&#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(j = i; j &gt; low; j--)&#123;</span><br><span class="line">            a[j] = a[j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        a[low] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h3><p>由于折半插入查找只是减少了比较的次数，没有优化记录的移动次数，所以时间复杂度依旧是O(n^2)</p>
<h2 id="2-路插入排序算法"><a href="#2-路插入排序算法" class="headerlink" title="2-路插入排序算法"></a>2-路插入排序算法</h2><p>2-路插入排序算法是在折半插入排序的基础上对其进行改进，减少其在排序过程中移动记录的次数从而提高效率。</p>
<h3 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h3><ul>
<li>设置一个同存储记录的数组大小相同的数组d，将无序表中第一个记录添加进d[0]的位置上，然后从无序表中第二个记录开始，同d[0]作比较：<ul>
<li>如何该值比d[0]大，则添加到其右侧</li>
<li>反之添加到其左侧</li>
<li>如果是比最大值小，但是比最小值大，则移动位置</li>
</ul>
</li>
</ul>
<p><strong>这里的数组d可以理解成一个环状数组</strong></p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> arr[], <span class="keyword">int</span> temp[], <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 记录temp数组中最大值和最小值的位置</span></span><br><span class="line">    <span class="keyword">int</span> first = <span class="number">0</span>, <span class="keyword">final</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 取数组中第一个元素</span></span><br><span class="line">    temp[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">// 待插入元素比最小的元素小，添加到圆环左边</span></span><br><span class="line">        <span class="keyword">if</span>(arr[i] &lt; temp[first])&#123;</span><br><span class="line">            first = (first - <span class="number">1</span> + n) % n;</span><br><span class="line">            temp[first] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 待插入元素比最大的元素大，添加到圆环右边</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] &gt; temp[<span class="keyword">final</span>])&#123;</span><br><span class="line">            <span class="keyword">final</span> = (<span class="keyword">final</span> + <span class="number">1</span> + n) % n;</span><br><span class="line">            temp[<span class="keyword">final</span>] = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 插入元素比最小的大，比最大的小</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当前k指向最大值位置下一位空位</span></span><br><span class="line">            <span class="keyword">int</span> k = (<span class="keyword">final</span> + <span class="number">1</span> + n) % n;</span><br><span class="line">            <span class="comment">// 当插入值比当前值小时，需要移动当前值的位置</span></span><br><span class="line">            <span class="keyword">while</span>(temp[((k - <span class="number">1</span>) + n) % n] &gt; arr[i])&#123;</span><br><span class="line">                temp[(k + n) % n] = temp[(k - <span class="number">1</span> + n) % n];</span><br><span class="line">                k = (k - <span class="number">1</span> + n) % n;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 插入该值</span></span><br><span class="line">            temp[(k + n) % n] = arr[i];</span><br><span class="line">            <span class="comment">// 更新最大值的位置</span></span><br><span class="line">            <span class="keyword">final</span> = (<span class="keyword">final</span> + <span class="number">1</span> + n) % n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将排序记录复制到原来的顺序表里</span></span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span>; k &lt; n; k ++)&#123;</span><br><span class="line">            arr[k] = temp[(first + k) % n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>2-路插入排序相比于折半插入排序，只是减少了移动记录的次数，所以时间复杂度仍然为O(n^2)</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序也是一种插入排序，它是直接插入排序的更高级版本，也称为<code>缩小增量排序</code></p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>希尔排序是把记录按下标的一定增量分组，对魅族使用直接插入排序算法排序；随着增量逐渐减少，魅族包含的关键词越来越多，当增量减少至1时，整个文件恰好被分成一组，则算法终止。</p>
<h3 id="算法思路-1"><a href="#算法思路-1" class="headerlink" title="算法思路"></a>算法思路</h3><ul>
<li>首先，选择希尔增量（对于增量的选择与证明是一个数学难题，一般常用的选择gap = length/2，则增量序列就可以表示为{n/2, (n/2)/2 …., 1}</li>
<li>将待排序列按照gap的大小分组，如gap = 5， 则分为5组，第0位的数据与第5位的数据分为一组</li>
<li>对分成的gap组进行直接插入排序</li>
<li>缩小增量，使得gap = gap/2</li>
<li>继续对分成的gap组进行直接插入排序</li>
<li>直到gap = 1结束</li>
</ul>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(T arr[], <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(gap &lt; n/<span class="number">3</span>)&#123;</span><br><span class="line">        gap = gap * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( gap &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = gap; i &lt; n; i++)&#123;</span><br><span class="line">            T temp = arr[i];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = i; i &gt;= gap &amp;&amp; temp &lt; arr[j - gap]; j -= gap)&#123;</span><br><span class="line">                arr[j] = arr[j - gap];</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    gap /= <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="时间复杂度-1"><a href="#时间复杂度-1" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>对于gap = length/2的增量，时间复杂度如下：</p>
<ul>
<li>最坏情况： O(n^2),但是通过大量研究表明，当增量序列为dlta[k]=2t-k+1-1（0≤k≤t≤⌊log2(n+1)⌋）时，可以获得不错的效率。</li>
</ul>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>sort_algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>binarySearch</title>
    <url>/algorithm/binarySearch/</url>
    <content><![CDATA[<h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul>
<li>对待查询的一组数据arr排序</li>
<li>设定一组待查询的数的上下限(max, min)，将待查询的数value与arr[(max+min)/2]比较<ul>
<li>value &gt; arr[(max+min)/2]， 则缩小范围使得min = (max+min)/2 +1</li>
<li>value &lt; arr[(max+min)/2]， 则缩小范围使得max = (max+min)/2 -1 </li>
<li>value == arr[(max+min)/2]， 则找到输出位置</li>
</ul>
</li>
<li>持续缩小范围，直到找到对应的值，若最终max == min，则该组数据中没有value值</li>
</ul>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><h5 id="非递归法"><a href="#非递归法" class="headerlink" title="非递归法"></a>非递归法</h5><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(T arr[], <span class="keyword">int</span> <span class="built_in">size</span>, T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="literal">nullptr</span> || <span class="built_in">size</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">min</span> = <span class="number">0</span>, <span class="built_in">max</span> = <span class="built_in">size</span><span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (<span class="built_in">max</span> + <span class="built_in">min</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">max</span> &gt;= <span class="built_in">min</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(value == arr[<span class="built_in">min</span>]) <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(value &gt; arr[mid]) <span class="built_in">min</span> = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">max</span> = mid - <span class="number">1</span>;</span><br><span class="line">        mid = (<span class="built_in">max</span>+<span class="built_in">min</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(T arr[], <span class="keyword">int</span> <span class="built_in">min</span>, <span class="keyword">int</span> <span class="built_in">max</span>, T value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr == <span class="literal">nullptr</span> || <span class="built_in">size</span> == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = (<span class="built_in">max</span>+<span class="built_in">min</span>)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(arr[mid] == value) <span class="keyword">return</span> mid;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &gt; value) <span class="keyword">return</span> binarySearch(arr, <span class="built_in">min</span>, mid<span class="number">-1</span>, value);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(arr[mid] &lt; value) <span class="keyword">return</span> binarySearch(arr, mid+<span class="number">1</span>, <span class="built_in">max</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><blockquote>
<p>mid = min + (max-min)/2;</p>
</blockquote>
<h2 id="时空复杂度"><a href="#时空复杂度" class="headerlink" title="时空复杂度"></a>时空复杂度</h2><p>二分搜索法的时间复杂度为O(logn)</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>search_algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>quickSort</title>
    <url>/algorithm/sortAlgorithm/</url>
    <content><![CDATA[<h1 id="快速排序算法"><a href="#快速排序算法" class="headerlink" title="快速排序算法"></a>快速排序算法</h1><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><p>快速排序算法分为以下几个步骤：</p>
<ul>
<li>在数组中选一个基数（通常为数组第一个）</li>
<li>将数组中小于基准数的数据移到基准数左边，大于基准数的移到右边</li>
<li>对于基准数左右两边的数组，不断重复以上两个过程，知道每个自己只有一个元素，即为全部有序</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">#inclde&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">using namespace std;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string"></span></span></span><br><span class="line"><span class="meta"><span class="meta-string">void quickSort(int *arr, int begin, int end)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    if(begin &lt; end)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">    &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        int temp = arr[begin]; //基准数</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        int i = begin;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        int j = end;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        while(i &lt; j)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            while(i &lt; j &amp;&amp; arr[j] &gt; temp)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                j--;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            arr[i] = arr[j];</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            while(i &lt; j &amp;&amp; arr[i] &lt;= temp)</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            &#123;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">                i++;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">            arr[j] = arr[i];</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        arr[i] = temp;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        quickSort(arr, begin, i - 1);</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">        quickSort(arr, i + 1; end);</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">     &#125;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">     else return;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&#125;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h2><p>空间复杂度： 快速排序是一种原地排序，只需要一个很小的 栈作为辅助空间，空间复杂度为O(log2n),所以适合在数据集比较大的时候使用。</p>
<p>时间复杂度： 最好的情况是O(n), 最差的情况是O(n^2)，所以平时说O(nlogn)作为其平均时间复杂度。</p>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>sort_algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>chrome01</title>
    <url>/chrome/chrome01/</url>
    <content><![CDATA[<h1 id="chrome-extension开发"><a href="#chrome-extension开发" class="headerlink" title="chrome extension开发"></a>chrome extension开发</h1><p>增强浏览器功能，轻松实现属于自己的“定制版”浏览器，等等。<br>Chrome插件提供了很多实用API供我们使用，包括但不限于：</p>
<ul>
<li>书签控制；</li>
<li>下载控制；</li>
<li>窗口控制；</li>
<li>标签控制；</li>
<li>网络请求控制，各类事件监听；</li>
<li>自定义原生菜单；</li>
<li>完善的通信机制；</li>
<li>等等</li>
</ul>
<h2 id="manifest-json"><a href="#manifest-json" class="headerlink" title="manifest.json"></a>manifest.json</h2><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 扩展名称</span></span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"MyExtension"</span>,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 版本。由1到4个整数构成。多个整数间用"."隔开</span></span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0"</span>,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// manifest文件版本号。Chrome18开始必须为2</span></span><br><span class="line">  <span class="attr">"manifest_version"</span>: <span class="number">2</span>,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 描述。132个字符以内</span></span><br><span class="line">  <span class="attr">"description"</span>: <span class="string">""</span>,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 扩展图标。推荐大小16，48，128</span></span><br><span class="line">  <span class="attr">"icons"</span>: &#123;</span><br><span class="line">    <span class="attr">"16"</span>: <span class="string">"image/icon-16.png"</span>,</span><br><span class="line">    <span class="attr">"48"</span>: <span class="string">"image/icon-48.png"</span>,</span><br><span class="line">    <span class="attr">"128"</span>: <span class="string">"image/icon-128.png"</span></span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 语言</span></span><br><span class="line">  <span class="attr">"default_locale"</span>: <span class="string">"en"</span>,</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// devtools页面入口，注意只能指向一个HTML文件，不能是JS文件</span></span><br><span class="line">	<span class="attr">"devtools_page"</span>: <span class="string">"html/devtools.html"</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 地址栏右侧图标管理，含图标及弹出页面的设置等</span></span><br><span class="line">  <span class="comment">// 建议至少保留一个设置，不然扩展图标是暗的</span></span><br><span class="line">  <span class="string">"browser_action"</span>: &#123;</span><br><span class="line">    <span class="comment">// 浏览器右侧上的图标</span></span><br><span class="line">    <span class="attr">"default_icon"</span>: <span class="string">"image/icon-128.png"</span>,</span><br><span class="line">    <span class="attr">"default_title"</span>: <span class="string">"My Message"</span>,</span><br><span class="line">    <span class="attr">"default_popup"</span>: <span class="string">"html/browser.html"</span></span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 地址栏最后附加图标。含图标及行为等（当某些特定页面打开菜显示的图标）</span></span><br><span class="line">  <span class="attr">"page_action"</span>: &#123;</span><br><span class="line">    <span class="attr">"default_icon"</span>: <span class="string">"image/icon-48.png"</span>,</span><br><span class="line">    <span class="attr">"default_title"</span>: <span class="string">"My Test"</span>,</span><br><span class="line">    <span class="attr">"default_popup"</span>: <span class="string">"html/page.html"</span></span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 主题，用于更改整个浏览器的外观</span></span><br><span class="line">  <span class="attr">"theme"</span>: &#123;&#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 指定扩展需要跳转到的URL</span></span><br><span class="line">  <span class="attr">"app"</span>: &#123;&#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 指定扩展进程的background运行环境及运行脚本</span></span><br><span class="line">  <span class="attr">"background"</span>: &#123;</span><br><span class="line">    <span class="comment">// 两种指定方法，如果指定JS，那么会自动生成一个背景页</span></span><br><span class="line">    <span class="attr">"scripts"</span>: [</span><br><span class="line">      <span class="string">"lib/jquery-3.3.1.min.js"</span>,</span><br><span class="line">      <span class="string">"js/background.js"</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"page"</span>:<span class="string">"html/background.html"</span></span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 替换页面</span></span><br><span class="line">  <span class="attr">"chrome_url_overrides"</span>: &#123;</span><br><span class="line">    <span class="attr">"pageToOverride"</span>: <span class="string">"html/overrides.html"</span>,</span><br><span class="line">    <span class="comment">//覆盖浏览器默认页面</span></span><br><span class="line">    <span class="attr">"newtab"</span>: <span class="string">"html/newtab.html"</span> </span><br><span class="line">  &#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 指定在web页面运行的脚本/插入的css及运行/插入时机</span></span><br><span class="line">  <span class="attr">"content_scripts"</span>: [&#123;</span><br><span class="line">    <span class="comment">// "&lt;all_urls&gt;" 表示匹配所有地址</span></span><br><span class="line">    <span class="comment">// 或者"matches": ["http://*/*", "https://*/*"],</span></span><br><span class="line">    <span class="attr">"matches"</span>: [<span class="string">"https://www.baidu.com/*"</span>],</span><br><span class="line">    <span class="attr">"css"</span>: [<span class="string">"css/mystyles.css"</span>],</span><br><span class="line">    <span class="attr">"js"</span>: [<span class="string">"lib/jquery-3.3.1.min.js"</span>, <span class="string">"js/content.js"</span>],</span><br><span class="line">    <span class="comment">//代码注入时间，可选值： “document_start", "document_end", or "document_idle"（表示页面空闲时）</span></span><br><span class="line">    <span class="attr">"run_at"</span>: <span class="string">"document_idle"</span></span><br><span class="line">  &#125;],</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 安全策略</span></span><br><span class="line">  <span class="attr">"content_security_policy"</span>: <span class="string">",</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">  "</span>file_browser_handlers<span class="string">": [],</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">  // 扩展的官方主页</span></span><br><span class="line"><span class="string">  // 扩展的主页 url。扩展的管理界面里面将有一个链接指向这个url。如果你将扩展放在自己的网站上，这个url就很有用了。如果你通过了Extensions Gallery和Chrome Web Store来分发扩展，主页 缺省就是扩展的页面。</span></span><br><span class="line"><span class="string">  "</span>homepage_url<span class="string">": "</span>http:<span class="comment">//xxx",</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 插件在隐私模式下的配置</span></span><br><span class="line">  <span class="string">"incognito"</span>: <span class="string">"spanning"</span>,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 用户操作意图描述</span></span><br><span class="line">  <span class="attr">"intents"</span>: &#123;&#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 扩展唯一标识。不需要人为指定</span></span><br><span class="line">  <span class="attr">"key"</span>: <span class="string">",</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">  // 扩展所需chrome的最小版本</span></span><br><span class="line"><span class="string">  "</span>minimum_chrome_version<span class="string">": "</span><span class="number">1.0</span><span class="string">",</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">  // 消息与本地处理模块映射</span></span><br><span class="line"><span class="string">  "</span>nacl_modules<span class="string">": [],</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">  // 是否允许脱机运行</span></span><br><span class="line"><span class="string">  "</span>offline_enabled<span class="string">": true,</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">  // ominbox即地址栏。用于响应地址栏的输入事件</span></span><br><span class="line"><span class="string">  // 向地址栏注册一个关键字以提供搜索建议，只能设置一个关键字</span></span><br><span class="line"><span class="string">  "</span>omnibox<span class="string">": &#123;</span></span><br><span class="line"><span class="string">    "</span>keyword<span class="string">": "</span>myKey<span class="string">"</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">  // 选项页。用于在扩展管理页面跳转到选项设置</span></span><br><span class="line"><span class="string">  "</span>options_page<span class="string">": "</span>aFile.html<span class="string">",</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">  // 申请权限</span></span><br><span class="line"><span class="string">  "</span>permissions<span class="string">": [</span></span><br><span class="line"><span class="string">    "</span>contextMenus<span class="string">", // 右键菜单</span></span><br><span class="line"><span class="string">    "</span>notifications<span class="string">", //通知</span></span><br><span class="line"><span class="string">    "</span>webReuqest<span class="string">", // web通知</span></span><br><span class="line"><span class="string">    "</span>webRequestBlocking<span class="string">",</span></span><br><span class="line"><span class="string">    "</span>storage<span class="string">", //插件本地存储</span></span><br><span class="line"><span class="string">    "</span>https:<span class="comment">//www.baidu.com/*", // 可以通过executeScript或者insertCSS访问的网站(http://*/*; https://*/*)</span></span><br><span class="line">    <span class="string">"background"</span>,</span><br><span class="line">    <span class="attr">"tabs"</span> <span class="comment">// 标签</span></span><br><span class="line">  ],</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 扩展。可调用第三方扩展</span></span><br><span class="line">  "plugins": [&#123;</span><br><span class="line">    "path": "extension_plugin.dll",</span><br><span class="line">    "public": true</span><br><span class="line">  &#125;],</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 指定所需要的特殊技术。目前只支持"3D"</span></span><br><span class="line">  "requirements": &#123;&#125;,</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 自动升级</span></span><br><span class="line">  "update_url": "http://path/to/updateInfo.xml",</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 普通页面能够直接访问的插件资源列表，如果不设置则无法直接访问。</span></span><br><span class="line">  <span class="comment">// 指定资源路径，为String数组</span></span><br><span class="line">  "web_accessible_resources": [],</span><br><span class="line"></span><br><span class="line">	"options_ui":</span><br><span class="line">	&#123;</span><br><span class="line">    <span class="attr">"page"</span>: <span class="string">"html/options.html"</span>,</span><br><span class="line">    <span class="comment">// 添加一些默认的样式，推荐使用</span></span><br><span class="line">    <span class="attr">"chrome_style"</span>: <span class="literal">true</span></span><br><span class="line">	&#125;,</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="上述属性含义"><a href="#上述属性含义" class="headerlink" title="上述属性含义"></a>上述属性含义</h3><ol>
<li>name 扩展名称</li>
<li>version 插件的版本</li>
<li>manifest_version manifest 配置文件的版本</li>
<li>description 对插件功能的描述</li>
<li>icons 插件的图标</li>
<li>browser_action 定义插件的图标，点击插件时弹出的页面，插件的标题</li>
<li>backdround 背景页，扩展进程的背景运行环境，可以拦截修改请求等等</li>
<li>content_scripts 内容脚本，可以指定在什么时机向什么页面插入什么脚本或者css资源</li>
<li>permissions 权限申请项，比如存储权限storage，请求拦截权限webReuqest， webRequestBlocking等等</li>
</ol>
<h2 id="content-script文件"><a href="#content-script文件" class="headerlink" title="content-script文件"></a>content-script文件</h2><blockquote>
<p>content-script文件是嵌入到匹配的网页中的脚本，但是又与页面中的脚本隔离开。虽然可以操纵页面上的DOM元素，但是却不能够使用页面脚本的API。也就是运行环境与页面的脚本是隔离开的。</p>
</blockquote>
<p>借助content-scripts我们可以实现通过配置的方式轻松向指定页面注入JS和CSS，最常见的比如：广告屏蔽、页面CSS定制等等。</p>
<p>示例配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 需要直接注入页面的JS</span></span><br><span class="line">    <span class="attr">"content_scripts"</span>: </span><br><span class="line">    [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//"matches": ["http://*/*", "https://*/*"],</span></span><br><span class="line">            <span class="comment">// "&lt;all_urls&gt;" 表示匹配所有地址</span></span><br><span class="line">            <span class="attr">"matches"</span>: [<span class="string">"&lt;all_urls&gt;"</span>],</span><br><span class="line">            <span class="comment">// 多个JS按顺序注入</span></span><br><span class="line">            <span class="attr">"js"</span>: [<span class="string">"js/jquery-1.8.3.js"</span>, <span class="string">"js/content-script.js"</span>],</span><br><span class="line">            <span class="comment">// JS的注入可以随便一点，但是CSS的注意就要千万小心了，因为一不小心就可能影响全局样式</span></span><br><span class="line">            <span class="attr">"css"</span>: [<span class="string">"css/custom.css"</span>],</span><br><span class="line">            <span class="comment">// 代码注入的时间，可选值： "document_start", "document_end", or "document_idle"，最后一个表示页面空闲时，默认document_idle</span></span><br><span class="line">            <span class="attr">"run_at"</span>: <span class="string">"document_start"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>content-script和原始页面共享DOM，但是不共享JS，如要访问页面JS（例如某个JS变量），只能通过injected js来实现。content-scripts不能访问绝大多数chrome.xxx.api，除了下面这4种：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">chrome.extension(getURL, inIncognitoContext, lastError, onRequest, sendRequest)</span><br><span class="line"></span><br><span class="line">chrome.i18n</span><br><span class="line"></span><br><span class="line">chrome.runtime(connect, getManifest, getURL, id, onConnect, onMessage, sendMessage)</span><br><span class="line"></span><br><span class="line">chrome.storage</span><br></pre></td></tr></table></figure>

<h3 id="动态注入页面"><a href="#动态注入页面" class="headerlink" title="动态注入页面"></a>动态注入页面</h3><p>除了可以在manifest中配置需要注入的页面以外，还可以动态的注入到页面中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直接注入代码</span></span><br><span class="line">chrome.browserAction.onClicked.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">tab</span>) </span>&#123;</span><br><span class="line">      chrome.tabs.executeScript(&#123;</span><br><span class="line">        code:<span class="string">'document.body.style.backgroundColor="red"'</span></span><br><span class="line">      &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//注入脚本文件</span></span><br><span class="line">chrome.tabs.executeScript(<span class="literal">null</span>, &#123;<span class="attr">file</span>: <span class="string">"content_script.js"</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>同时，要在manifest文件中配置权限:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"permissions": [</span><br><span class="line">	<span class="string">"activeTab"</span></span><br><span class="line">],</span><br></pre></td></tr></table></figure>
<h2 id="background文件"><a href="#background文件" class="headerlink" title="background文件"></a>background文件</h2><blockquote>
<p>background文件可以使扩赞常驻后台，比较常用的是指定子属性scripts，表示在扩展启动时自动创建一个包含所有指定脚本的页面。它的生命周期是插件中所有类型页面中最长的，它随着浏览器的打开而打开，随着浏览器的关闭而关闭，所以通常把需要一直运行的、启动就运行的、全局的代码放在background里面。</p>
</blockquote>
<p>background的权限非常高，几乎可以调用所有的Chrome扩展API（除了devtools），而且它可以无限制跨域，也就是可以跨域访问任何网站而无需要求对方设置CORS。</p>
<blockquote>
<p>经过测试，其实不止是background，所有的直接通过chrome-extension://id/xx.html这种方式打开的网页都可以无限制跨域。</p>
</blockquote>
<h2 id="popup文件"><a href="#popup文件" class="headerlink" title="popup文件"></a>popup文件</h2><p>如果browser action拥有一个popup，popup会在用户点击图标后出现。popup可以包含任意你想要的HTML内容，并且会自适应大小，所以一般用来做临时性的交互。</p>
<p>在你的browser action中添加popup，创建弹出的内容的HTML文件。修改browser——action的manifest中default_popup字段来指定HTML文件，或者调用setPopup()方法。</p>
<blockquote>
<p>在权限上，它和background非常类似，它们之间最大的不同是生命周期的不同，popup中可以直接通过chrome.extension.getBackgroundPage()获取background的window对象。</p>
</blockquote>
<h2 id="消息通信机制"><a href="#消息通信机制" class="headerlink" title="消息通信机制"></a>消息通信机制</h2><p><a href="https://github.com/ChhXin/chrome-message" target="_blank" rel="noopener">代码</a></p>
<img src="/chrome/chrome01/system.png" alt="system" style="zoom:50%;">

<h3 id="popup-html文件"><a href="#popup-html文件" class="headerlink" title="popup.html文件"></a>popup.html文件</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"width: 300px"</span>&gt;</span>	</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">width</span>=<span class="string">"200px"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">"margin:5px 5px 5px 5px"</span> <span class="attr">id</span>=<span class="string">"con"</span>&gt;</span>popup发送消息给content_scripts<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">"margin:5px 5px 5px 5px"</span> <span class="attr">id</span>=<span class="string">"bg"</span>&gt;</span>popup调用background的js函数<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">style</span>=<span class="string">"margin:5px 5px 5px 5px"</span> <span class="attr">id</span>=<span class="string">"bgtocon"</span>&gt;</span>background发送消息给content_scripts<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"js/popup.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="popup-js文件"><a href="#popup-js文件" class="headerlink" title="popup.js文件"></a>popup.js文件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// popup调用background的js函数</span></span><br><span class="line">$(<span class="string">'#bg'</span>).click(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="comment">//alert("调用background的js函数");</span></span><br><span class="line">	<span class="keyword">var</span> bg = chrome.extension.getBackgroundPage();</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">123123</span>, bg)</span><br><span class="line">	bg.bgtest();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">// popup主动发消息给content-script</span></span><br><span class="line">$(<span class="string">'#con'</span>).click(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	alert(<span class="string">"popup发送消息给content-script"</span>);</span><br><span class="line">	sendMessageToContentScript(<span class="string">'你好，我是popup！'</span>, (response) =&gt; &#123;</span><br><span class="line">		<span class="keyword">if</span>(response) alert(<span class="string">'收到来自content-script的回复：'</span>+response);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// popup调用background的js函数</span></span><br><span class="line">$(<span class="string">'#bgtocon'</span>).click(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">	<span class="keyword">var</span> bg = chrome.extension.getBackgroundPage();</span><br><span class="line">	bg.TT();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前选项卡ID</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCurrentTabId</span>(<span class="params">callback</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chrome.tabs.query(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">currentWindow</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">tabs</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(callback) callback(tabs.length ? tabs[<span class="number">0</span>].id: <span class="literal">null</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向content-script主动发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMessageToContentScript</span>(<span class="params">message, callback</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	getCurrentTabId(<span class="function">(<span class="params">tabId</span>) =&gt;</span></span><br><span class="line">	&#123;</span><br><span class="line">		chrome.tabs.sendMessage(tabId, message, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(callback) callback(response);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="background-js文件"><a href="#background-js文件" class="headerlink" title="background.js文件"></a>background.js文件</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bgtest</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	alert(<span class="string">"background的bgtest函数！"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听来自content-script的消息</span></span><br><span class="line">chrome.runtime.onMessage.addListener(<span class="function"><span class="keyword">function</span>(<span class="params">request, sender, sendResponse</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">'收到来自content-script的消息：'</span>);</span><br><span class="line">	<span class="built_in">console</span>.log(request, sender, sendResponse);</span><br><span class="line">	sendResponse(<span class="string">'我是background，我已收到你的消息：'</span> + <span class="built_in">JSON</span>.stringify(request));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// backgrond向context_scripts发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TT</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	</span><br><span class="line">	sendMessageToContentScript(<span class="string">'context_scripts你好，我是backgrond！'</span>, (response) =&gt; &#123;</span><br><span class="line">	<span class="keyword">if</span>(response) alert(<span class="string">'backgrond收到来自content-script的回复：'</span>+response);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取当前选项卡ID</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCurrentTabId</span>(<span class="params">callback</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	chrome.tabs.query(&#123;<span class="attr">active</span>: <span class="literal">true</span>, <span class="attr">currentWindow</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">tabs</span>)</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(callback) callback(tabs.length ? tabs[<span class="number">0</span>].id: <span class="literal">null</span>);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向content-script主动发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendMessageToContentScript</span>(<span class="params">message, callback</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	getCurrentTabId(<span class="function">(<span class="params">tabId</span>) =&gt;</span></span><br><span class="line">	&#123;</span><br><span class="line">		chrome.tabs.sendMessage(tabId, message, <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">if</span>(callback) callback(response);</span><br><span class="line">		&#125;);</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p><a href="https://www.cnblogs.com/liuxianan/p/chrome-plugin-develop.html" target="_blank" rel="noopener">干货文档</a></p>
]]></content>
      <categories>
        <category>chrome</category>
      </categories>
      <tags>
        <tag>chrome</tag>
      </tags>
  </entry>
  <entry>
    <title>react01</title>
    <url>/uncategorized/react01/</url>
    <content><![CDATA[<h1 id="使用express-typescript-antd构建前端项目"><a href="#使用express-typescript-antd构建前端项目" class="headerlink" title="使用express+typescript+antd构建前端项目"></a>使用express+typescript+antd构建前端项目</h1><ul>
<li>技术栈<br>react<br>typescript<br>antd<br>react-router-dom<br>react-redux<br>canvas<br>ES6<br>cookie<h1 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h1><h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2></li>
</ul>
<p>react是前端三大模板之一，是一个用于构建用户界面的Javascript库。<br>react的核心思想是：封装组件。<br>react大体包含下面这些概念：</p>
<ul>
<li>组件</li>
<li>JSX</li>
<li>Virtual DOM</li>
<li>Data Flow</li>
</ul>
<p><a href="http://caibaojian.com/react/" target="_blank" rel="noopener">react中文文档</a></p>
<h2 id="antd"><a href="#antd" class="headerlink" title="antd"></a>antd</h2><p>antd是ReactUI框架<br><a href="https://ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">antd使用</a></p>
<h2 id="react-router-dom"><a href="#react-router-dom" class="headerlink" title="react-router-dom"></a>react-router-dom</h2><p>使用React构建的单页面应用，要想实现页面间的跳转，常用两个包实现这个需求：react-router和react-router-dom。</p>
<p><a href="https://www.jianshu.com/p/8954e9fb0c7e" target="_blank" rel="noopener">使用例子</a></p>
<h2 id="redux"><a href="#redux" class="headerlink" title="redux"></a>redux</h2><p>通过使用redux来管理数据流。redux是flux架构的一种实现。redux并不是完全依附于react机构，而是可以和任何UI层框架相结合。因此，为了更好得结合redux与react，对redux-flow的store有一个更好的全局性管理，我们还需要使用react-redux。</p>
<h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>React-Redux是Redux的官方React绑定库。它能够使React组件从Redux store中读取数据，并且向store分发actions以更新数据。<br><a href="https://segmentfault.com/a/1190000017064759" target="_blank" rel="noopener">react-redux中文文档</a></p>
<h1 id="redux-actions"><a href="#redux-actions" class="headerlink" title="redux-actions"></a>redux-actions</h1><p>为了更好地创建action和reducer，我们还会在项目中引入redux-actions：一个针对redux的一个FSA工具箱。可以相应简化与标准化action与reducer部分。</p>
<h2 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h2><p>canva 是HTML5中的新元素，你可以使用javascript用它来绘制图形、图标以及其它任何视觉性图像。它也可用于创建图片特效和动画。<br><a href="https://www.canvasapi.cn" target="_blank" rel="noopener">canvas ap文档</a></p>
<h2 id="create-react-app"><a href="#create-react-app" class="headerlink" title="create-react-app"></a>create-react-app</h2><p>create-react-app是一个官方支持的创建react单页应用程序的方法。它提供了一个零配置的现代构建设置。</p>
<h3 id="全局安装create-react-app"><a href="#全局安装create-react-app" class="headerlink" title="全局安装create-react-app"></a>全局安装create-react-app</h3><blockquote>
<p>npm install -g create-react-app</p>
</blockquote>
<h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><blockquote>
<p>npx create-react-app 项目名</p>
</blockquote>
<p><a href="https://www.html.cn/create-react-app/docs/getting-started/" target="_blank" rel="noopener">create-react-app 中文文档</a></p>
<h3 id="react-app-rewired"><a href="#react-app-rewired" class="headerlink" title="react-app-rewired"></a>react-app-rewired</h3><p>通过使用react-app-rewired插件，可以在不eject的情况下，覆盖create-react=app的配置<br>由于新的<a href="mailto:react-app-rewired@2.x">react-app-rewired@2.x</a>版本的关系，还需要安装customize-cra</p>
<h2 id="babel-plugin-import"><a href="#babel-plugin-import" class="headerlink" title="babel-plugin-import"></a>babel-plugin-import</h2><p>通过使用babel-plugin-import可以按需引入组件，可以配置babel按需引入antd模块</p>
<h2 id="react-hot-loader"><a href="#react-hot-loader" class="headerlink" title="react-hot-loader"></a>react-hot-loader</h2><p>通过使用react-hot-loader实现代码修改热更新。</p>
<h2 id="less-amp-amp-less-loader"><a href="#less-amp-amp-less-loader" class="headerlink" title="less &amp;&amp; less-loader"></a>less &amp;&amp; less-loader</h2><p>less(Leaner Style Sheets 的缩写)是一门向后兼容的css扩展语言。less为css语言增加了少许方便的扩展。</p>
<p><a href="https://less.bootcss.com" target="_blank" rel="noopener">less 中文文档</a></p>
<h1 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h1><blockquote>
<p>assets————存放静态资源<br>components————存放公共组件<br>pages————存放页面<br>store————存放状态管理数据流文件<br>utils————存放函数工具<br>api.ts————定义api接口文件<br>App.css————定义全局css<br>App.ts————定义项目入口组件<br>global.d.ts————定义全局的声明文件<br>index.tsx————入口文件<br>router.ts————路由配置表</p>
</blockquote>
<h1 id="action"><a href="#action" class="headerlink" title="action"></a>action</h1><p>action是一个object类型，对于action的结构有Flux相关的标准化建议FSA<br>一个action必须要包含type属性，同时 它还有三个可选属性error、payload和meta。</p>
<p>1）type属性相当于是action的标识，通过它可以区分不同的action，其类型只能是字符串常量或Symbol<br>2）playload属性是可选的，可以是任何类型。playload可以用来装载数据；在error为true的时候，playload一般是用来装载错误信息<br>3）error属性是可选的，一般当出现错误时其值为true；如果是其它值，不被理解为出现错误<br>4）meta属性可以是任何类型，它一般会包括一些不合适在playload中放置的数据</p>
<h2 id="使用redux-actions对actions进行创建与管理"><a href="#使用redux-actions对actions进行创建与管理" class="headerlink" title="使用redux-actions对actions进行创建与管理"></a>使用redux-actions对actions进行创建与管理</h2><p>1）createAction(type, payloadCreator = Identity, ?metaCreator)<br>2）createActions相当于对action创建器的一个包装，会放回一个FSA，使用这个返回的FSA可以创建具体的action<br>3）payloadCreator是一个function，处理并返回需要的payload；如果空缺，会使用默认方法。如果传入一个Error对象则会自动将action的error属性设为true</p>
<h1 id="store"><a href="#store" class="headerlink" title="store"></a>store</h1><p>承接了react的state， store里面的数据是不可修改的，只能返回一个new state。<br>页面中所有的渲染操作所需数据都是从store拽下来的。<br>store有四个方法：</p>
<ul>
<li>getState：获取应用当前State</li>
<li>subscribe：添加一个变化监听器</li>
<li>dispatch：分发action。修改State</li>
<li>replaceReducer：替换store当前用来处理state的reducer<br>常用的dispatch是修改State的唯一途径</li>
</ul>
<h1 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h1><p>provider模块是作为整个App的容器，原有的App Container的基础上再包上一层。它的工作就是接受Redux的store作为props，并将其声明为context的属性之一。子组件可以在声明了contextTypes之后方便的通过this.context.store访问store。</p>
<h1 id="component"><a href="#component" class="headerlink" title="component"></a>component</h1><p>需要渲染的组件，组件里面的数据是从store里面来的。这个组件可以导入其它模块</p>
<h1 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h1><h1 id="action-1"><a href="#action-1" class="headerlink" title="action"></a>action</h1><h1 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h1><h1 id="store、reducer、container工作流程"><a href="#store、reducer、container工作流程" class="headerlink" title="store、reducer、container工作流程"></a>store、reducer、container工作流程</h1><p><img src="/uncategorized/react01/store-reduce-action-components.png" alt></p>
]]></content>
  </entry>
  <entry>
    <title>express01</title>
    <url>/uncategorized/express01/</url>
    <content><![CDATA[<h1 id="项目环境搭建"><a href="#项目环境搭建" class="headerlink" title="项目环境搭建"></a>项目环境搭建</h1><h2 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h2><p>在新建的文件夹下初始化项目：</p>
<blockquote>
<p>npm init</p>
</blockquote>
<h2 id="安装express生成器"><a href="#安装express生成器" class="headerlink" title="安装express生成器"></a>安装express生成器</h2><p>通过应用生成器工具express-generatoe可以快速创建一个应用的骨架。express-generatoe包含了express命令行工具。</p>
<blockquote>
<p>npm install express-generator -g</p>
</blockquote>
<h2 id="创建应用"><a href="#创建应用" class="headerlink" title="创建应用"></a>创建应用</h2><p>创建一个名为myapp的Express应用，并且设置为使用Pug模板引擎</p>
<blockquote>
<p>express –view=pug myapp</p>
</blockquote>
<p>结果生成myapp文件夹</p>
<h2 id="模板引擎"><a href="#模板引擎" class="headerlink" title="模板引擎"></a>模板引擎</h2><p>模板引擎能让我们将数据与Javascript代码潜入到html中，然后将这html返回给客户端。<br>比较流行的引擎为ejs， mustache， jade。这里先使用pug，之后尝试不同的引擎。</p>
<h2 id="安装所需的包依赖"><a href="#安装所需的包依赖" class="headerlink" title="安装所需的包依赖"></a>安装所需的包依赖</h2><p>进入myapp文件夹：</p>
<blockquote>
<p>npm install</p>
</blockquote>
<h2 id="安装nodemon"><a href="#安装nodemon" class="headerlink" title="安装nodemon"></a>安装nodemon</h2><p>nodemon将监视启动目录中的文件，如果有任何文件改变，nodemon将自动重新启动node应用程序<br>全局安装：</p>
<blockquote>
<p>npm install -g nodemon</p>
</blockquote>
<p>本地安装（开发环境下）:</p>
<blockquote>
<p>npm install –save-dev nodemon</p>
</blockquote>
<h2 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h2><blockquote>
<p>nodemon</p>
</blockquote>
<p>这时可在3000端口查看</p>
<h2 id="安装插件babel-register、babel-preset-env"><a href="#安装插件babel-register、babel-preset-env" class="headerlink" title="安装插件babel-register、babel-preset-env"></a>安装插件babel-register、babel-preset-env</h2><blockquote>
<p>npm install –save babel-register babel-preset-env</p>
</blockquote>
<p>babel是一个工具链，主要用户将ECMAScript 2015+版本的代码转换为向后兼容的JavaScript语法，以便能够运行在当前和旧版本的浏览器或者其他环境中。<br>官方文档：<a href="https://www.babeljs.cn/docs/" target="_blank" rel="noopener">babel中文文档</a></p>
]]></content>
  </entry>
  <entry>
    <title>mongodb01</title>
    <url>/uncategorized/mongodb01/</url>
    <content><![CDATA[<h1 id="mongoDB-基本命令"><a href="#mongoDB-基本命令" class="headerlink" title="mongoDB 基本命令"></a>mongoDB 基本命令</h1><ul>
<li>配置的端口<br>端口：27017</li>
<li>启动命令<blockquote>
<p>mongod –config /opt/soft/mongodb/mongodb.conf</p>
</blockquote>
</li>
<li>登陆<blockquote>
<p>mongo</p>
</blockquote>
</li>
<li>关闭<blockquote>
<p>ps aux | grep mongodb //然后直接kill进程<br>or<br>db.shutdownServer()</p>
</blockquote>
</li>
</ul>
<h1 id="mongoDB-简介"><a href="#mongoDB-简介" class="headerlink" title="mongoDB 简介"></a>mongoDB 简介</h1><p>mongoDB是由数据库（database），集合（collection），文档对象（document）三个层次组成，与关系型数据库的比较如下：</p>
<table>
<thead>
<tr>
<th align="center">对比</th>
<th align="center">MongoD</th>
<th align="center">MySQL Oracle</th>
</tr>
</thead>
<tbody><tr>
<td align="center">表</td>
<td align="center">集合</td>
<td align="center">二维表table</td>
</tr>
<tr>
<td align="center">表的一行数据</td>
<td align="center">文档document</td>
<td align="center">一条记录record</td>
</tr>
<tr>
<td align="center">表字段</td>
<td align="center">键key</td>
<td align="center">字段field</td>
</tr>
<tr>
<td align="center">字段值</td>
<td align="center">值value</td>
<td align="center">值value</td>
</tr>
<tr>
<td align="center">主外键</td>
<td align="center">无</td>
<td align="center">PK,FK</td>
</tr>
</tbody></table>
<p>mongoDB里的集合（collection）对应于关系型数据库里的表，但是集合中没有列、行和关系的概念，集合中只有文档，一个文档就相当于一条记录，这体现了模式自由的特点。</p>
<h1 id="mongoDB-常用命令"><a href="#mongoDB-常用命令" class="headerlink" title="mongoDB 常用命令"></a>mongoDB 常用命令</h1><h2 id="查看mongoDB帮助文档"><a href="#查看mongoDB帮助文档" class="headerlink" title="查看mongoDB帮助文档"></a>查看mongoDB帮助文档</h2><blockquote>
<p>mongo -h</p>
</blockquote>
<h2 id="用户操作"><a href="#用户操作" class="headerlink" title="用户操作"></a>用户操作</h2><h3 id="创建管理员用户"><a href="#创建管理员用户" class="headerlink" title="创建管理员用户"></a>创建管理员用户</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="keyword">admin</span></span><br><span class="line">db.createUser(</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">user</span>: <span class="string">"root"</span>,</span><br><span class="line">		pwd: <span class="string">"123456"</span>,</span><br><span class="line">		<span class="keyword">roles</span>: [&#123;<span class="keyword">role</span>:<span class="string">"userAdminAnyDatabase"</span>, db: <span class="string">"admin"</span>&#125;, <span class="string">"readWriteAnyDatabse"</span>]</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="用户身份验证"><a href="#用户身份验证" class="headerlink" title="用户身份验证"></a>用户身份验证</h3><blockquote>
<p>dn.auth(“admin”, “123456”)</p>
</blockquote>
<h3 id="查看创建的管理员账号"><a href="#查看创建的管理员账号" class="headerlink" title="查看创建的管理员账号"></a>查看创建的管理员账号</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use admin</span><br><span class="line">db.getUser(&quot;root&quot;)</span><br></pre></td></tr></table></figure>
<h3 id="连接mongoDB"><a href="#连接mongoDB" class="headerlink" title="连接mongoDB"></a>连接mongoDB</h3><h4 id="直接连接"><a href="#直接连接" class="headerlink" title="直接连接"></a>直接连接</h4><blockquote>
<p>mongo -u “root” –authenticationDatabase “admin” -p “123456”</p>
</blockquote>
<h4 id="登陆后进行验证"><a href="#登陆后进行验证" class="headerlink" title="登陆后进行验证"></a>登陆后进行验证</h4><blockquote>
<p>mongo<br>use admin<br>db.auth(“root”, “123456”)</p>
</blockquote>
<h3 id="创建普通用户"><a href="#创建普通用户" class="headerlink" title="创建普通用户"></a>创建普通用户</h3><ul>
<li>权限： 读写数据库test，只读数据库reporting</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">use test</span><br><span class="line">db.createUser(</span><br><span class="line">	&#123;</span><br><span class="line">		user: &quot;zaq&quot;</span><br><span class="line">		pwd: &quot;123456&quot;</span><br><span class="line">		roles:[&#123;role: &quot;readWrite&quot;, db: &quot;test&quot;&#125;,</span><br><span class="line">			&#123;role: &quot;read&quot;, db: &quot;reporting&quot;&#125;]</span><br><span class="line">	&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h3 id="显示当前所有用户-角色"><a href="#显示当前所有用户-角色" class="headerlink" title="显示当前所有用户/角色"></a>显示当前所有用户/角色</h3><blockquote>
<p>show people<br>show roles</p>
</blockquote>
<h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><blockquote>
<p>db.removeUser(“zaq”)</p>
</blockquote>
<h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><h3 id="查询所有库"><a href="#查询所有库" class="headerlink" title="查询所有库"></a>查询所有库</h3><blockquote>
<p>show dbs</p>
</blockquote>
<h3 id="查询库中的连接"><a href="#查询库中的连接" class="headerlink" title="查询库中的连接"></a>查询库中的连接</h3><blockquote>
<p>show collections</p>
</blockquote>
<h3 id="创建-切换数据库"><a href="#创建-切换数据库" class="headerlink" title="创建/切换数据库"></a>创建/切换数据库</h3><blockquote>
<p>use test #若没有test数据库就会直接创建</p>
</blockquote>
<h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><blockquote>
<p>db.dropDatabase()</p>
</blockquote>
<h3 id="获取数据库名称"><a href="#获取数据库名称" class="headerlink" title="获取数据库名称"></a>获取数据库名称</h3><blockquote>
<p>db.getName()</p>
</blockquote>
<h3 id="获取数据库状态"><a href="#获取数据库状态" class="headerlink" title="获取数据库状态"></a>获取数据库状态</h3><blockquote>
<p>db.stats()</p>
</blockquote>
<h3 id="获取当前db版本"><a href="#获取当前db版本" class="headerlink" title="获取当前db版本"></a>获取当前db版本</h3><blockquote>
<p>db.version()</p>
</blockquote>
<h3 id="查看当前db的链接机器地址"><a href="#查看当前db的链接机器地址" class="headerlink" title="查看当前db的链接机器地址"></a>查看当前db的链接机器地址</h3><blockquote>
<p>db.getMongo();</p>
</blockquote>
<h3 id="从指定主机上克隆数据库"><a href="#从指定主机上克隆数据库" class="headerlink" title="从指定主机上克隆数据库"></a>从指定主机上克隆数据库</h3><blockquote>
<p>db.cloneDatabase(“127.0.0.1”)</p>
</blockquote>
<h3 id="从指定机器上复制指定数据库数据到某一个数据库"><a href="#从指定机器上复制指定数据库数据到某一个数据库" class="headerlink" title="从指定机器上复制指定数据库数据到某一个数据库"></a>从指定机器上复制指定数据库数据到某一个数据库</h3><blockquote>
<p>db.copyDatabase(“aaa”, “test”, “127.0.0.1”)</p>
</blockquote>
<h3 id="修复数据库"><a href="#修复数据库" class="headerlink" title="修复数据库"></a>修复数据库</h3><blockquote>
<p>db.repairDatabase()</p>
</blockquote>
<h2 id="集合（collection）操作"><a href="#集合（collection）操作" class="headerlink" title="集合（collection）操作"></a>集合（collection）操作</h2><h3 id="创建一个聚集集合（table）"><a href="#创建一个聚集集合（table）" class="headerlink" title="创建一个聚集集合（table）"></a>创建一个聚集集合（table）</h3><blockquote>
<p>db.createCollection(“human”, {“size”: 1024, capped: true, max: 100});// 指定数据库大小1024，最大存放100个文档，满了就会删除旧文档<br>db.createCollection(“people”)</p>
</blockquote>
<h3 id="查看集合状态"><a href="#查看集合状态" class="headerlink" title="查看集合状态"></a>查看集合状态</h3><blockquote>
<p>db.people.stats()</p>
</blockquote>
<h3 id="获取指定集合"><a href="#获取指定集合" class="headerlink" title="获取指定集合"></a>获取指定集合</h3><blockquote>
<p>db.getCollection(“human”)</p>
</blockquote>
<h3 id="获取当前db中的所有集合"><a href="#获取当前db中的所有集合" class="headerlink" title="获取当前db中的所有集合"></a>获取当前db中的所有集合</h3><blockquote>
<p>db.getCollectionNames()</p>
</blockquote>
<h3 id="显示当前db所有聚集索引的状态"><a href="#显示当前db所有聚集索引的状态" class="headerlink" title="显示当前db所有聚集索引的状态"></a>显示当前db所有聚集索引的状态</h3><blockquote>
<p>db.printCollectionStats();</p>
</blockquote>
<h2 id="聚集集合查询-Collection"><a href="#聚集集合查询-Collection" class="headerlink" title="聚集集合查询(Collection)"></a>聚集集合查询(Collection)</h2><h3 id="查询所有记录"><a href="#查询所有记录" class="headerlink" title="查询所有记录"></a>查询所有记录</h3><blockquote>
<p>db.people.find()<br>相当于：<br>select * from people</p>
</blockquote>
<h3 id="查询去掉重复数据后的当前聚集集合中的某列数据"><a href="#查询去掉重复数据后的当前聚集集合中的某列数据" class="headerlink" title="查询去掉重复数据后的当前聚集集合中的某列数据"></a>查询去掉重复数据后的当前聚集集合中的某列数据</h3><blockquote>
<p>db.people.distinct(“name”)<br>相当于：<br>select distinct name from people</p>
</blockquote>
<h3 id="查询age-18的记录"><a href="#查询age-18的记录" class="headerlink" title="查询age=18的记录"></a>查询age=18的记录</h3><blockquote>
<p>db.people.find({“age”: 18})<br>相当于：<br>select * from people where age = 18</p>
</blockquote>
<h3 id="查询age-gt-18的记录"><a href="#查询age-gt-18的记录" class="headerlink" title="查询age &gt; 18的记录"></a>查询age &gt; 18的记录</h3><blockquote>
<p>db.people.find({age: {$gt: 18}})</p>
</blockquote>
<h3 id="查询age-gt-18的记录-1"><a href="#查询age-gt-18的记录-1" class="headerlink" title="查询age &gt;= 18的记录"></a>查询age &gt;= 18的记录</h3><blockquote>
<p>db.people.find({age: {$gte: 18}})</p>
</blockquote>
<h3 id="查询age-lt-18的记录"><a href="#查询age-lt-18的记录" class="headerlink" title="查询age &lt; 18的记录"></a>查询age &lt; 18的记录</h3><blockquote>
<p>db.people.find({age: {$lt: 18}})</p>
</blockquote>
<h3 id="查询age-lt-18的记录-1"><a href="#查询age-lt-18的记录-1" class="headerlink" title="查询age &lt;= 18的记录"></a>查询age &lt;= 18的记录</h3><blockquote>
<p>db.people.find({age: {$lte: 18}})</p>
</blockquote>
<h3 id="查询age-gt-23-并且-age-lt-26"><a href="#查询age-gt-23-并且-age-lt-26" class="headerlink" title="查询age &gt;= 23 并且 age &lt;= 26"></a>查询age &gt;= 23 并且 age &lt;= 26</h3><blockquote>
<p>db.people.find({age: {$gte: 23, $lte: 26}})</p>
</blockquote>
<p><a href="https://blog.csdn.net/qq_42039281/article/details/90265028" target="_blank" rel="noopener">https://blog.csdn.net/qq_42039281/article/details/90265028</a></p>
]]></content>
  </entry>
  <entry>
    <title>typescript01</title>
    <url>/uncategorized/typescript01/</url>
    <content><![CDATA[<h1 id="Typescript基本语法"><a href="#Typescript基本语法" class="headerlink" title="Typescript基本语法"></a>Typescript基本语法</h1><hr>
<h2 id="TypeScript的安装与编译"><a href="#TypeScript的安装与编译" class="headerlink" title="TypeScript的安装与编译"></a>TypeScript的安装与编译</h2><ul>
<li><p>全局安装typescript</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm -g install typescript</span><br></pre></td></tr></table></figure>
</li>
<li><p>在node.js+express的框架之下安装包</p>
</li>
</ul>
<ol>
<li>dependencies<blockquote>
<p>在项目下使用<code>npm install --save *</code>安装的包和版本</p>
</blockquote>
</li>
<li>devDependencies<blockquote>
<p>在项目下使用<code>npm install --save-dev *</code>安装的包，这些包仅仅在开发模式下安装。因为typescript仅在编译时检查代码，即仅在开发时有效，因此很多typescript相关模块以及带声名文件的第三方模块仅在开发模式下安装。</p>
</blockquote>
</li>
</ol>
<ul>
<li>TypeScript的编译<br>使用tsc命令编译，如：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsc helloWorld.ts</span><br></pre></td></tr></table></figure>
编译ts文件之后生成对应的helloWorld.js文件。</li>
</ul>
<hr>
<h2 id="Typescript的类型检查说明"><a href="#Typescript的类型检查说明" class="headerlink" title="Typescript的类型检查说明"></a>Typescript的类型检查说明</h2><p>Typescript只会进行静态类型检查，如何发现错误，编译的时候就会报错。日常一般搭配Eslint或Tslint使用，在编码过程中即会报出对应错误。</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><blockquote>
<p>通过在变量后面加上<code>:类型</code>声明变量的类型</p>
</blockquote>
<h4 id="boolean-布尔值"><a href="#boolean-布尔值" class="headerlink" title="boolean 布尔值"></a>boolean 布尔值</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isSuccess: <span class="built_in">boolean</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> isSuccess: <span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> isSuccess: <span class="built_in">boolean</span> = <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num: <span class="built_in">number</span> = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name: <span class="built_in">string</span> = <span class="string">'Cooper'</span>;</span><br><span class="line"><span class="keyword">let</span> templateStr: <span class="built_in">string</span> = <span class="string">`Hello, <span class="subst">$&#123;name&#125;</span>`</span>;<span class="comment">//es6模板字符串</span></span><br></pre></td></tr></table></figure>
<h4 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h4><p>在TypeScript中空值一般用来白噢是一个函数没有返回值</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name: <span class="built_in">string</span></span>): <span class="title">void</span></span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Null和Undefined"><a href="#Null和Undefined" class="headerlink" title="Null和Undefined"></a>Null和Undefined</h4><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> u: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> m: <span class="literal">null</span> = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<h4 id="任意值"><a href="#任意值" class="headerlink" title="任意值"></a>任意值</h4><p>定义为任意值的变量可以被赋值为任意类型。在任意类型的变量上访问任意属性和方法都是可以的。声明一个变量为any类型后，对其进行任意操作返回的都是any类型。未声明类型的变量默认为any类型。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> anyValue: <span class="built_in">any</span> = <span class="string">'123'</span>;</span><br><span class="line">anyValue = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><strong>不建议使用，TypeScript是为了更规范的书写JS代码</strong></p>
<h4 id="类型推论"><a href="#类型推论" class="headerlink" title="类型推论"></a>类型推论</h4><p>如果没有明确的指明某个变量的类型，那么TypeScript会依照类型推论的规则推导出一个类型</p>
<h4 id="联合属性"><a href="#联合属性" class="headerlink" title="联合属性"></a>联合属性</h4><p>联合类型表示取值可以为多种类型中的一种，各个类型间使用分割线<code>｜</code>连接。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> strOrNumValue: <span class="built_in">string</span> | <span class="built_in">number</span> = <span class="string">'test'</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>访问联合类型的属性和方法，当一个变量定义为联合类型，我们只能访问联合类型的公共方法和属性<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myToString</span>(<span class="params">something: <span class="built_in">string</span> | <span class="built_in">number</span></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> something.toString(); </span><br><span class="line">	<span class="comment">// 只有在string和number都具有toString()方法，才不会报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>聚合类型的变量在被赋值后，会根据类型推到的规则推导出一个类型，所以只能使用推导出来的类型具有的方法。</li>
</ul>
<hr>
<h2 id="对象的类型——接口"><a href="#对象的类型——接口" class="headerlink" title="对象的类型——接口"></a>对象的类型——接口</h2><p>在TypeScript中，我们用接口来定义对象的类型，接口命名，一般以大写字母I开头，I后面的首个字母大写。</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson &#123;</span><br><span class="line">	name: <span class="built_in">string</span>;</span><br><span class="line">	age: <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> Cooper: IPerson = &#123;</span><br><span class="line">	name: <span class="string">'Cooper'</span>,</span><br><span class="line">	age: <span class="number">23</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可选属性，用来表示某个对象中的属性是可选的。<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson&#123;</span><br><span class="line">	name: <span class="built_in">string</span>;</span><br><span class="line">	age?: <span class="built_in">number</span>;<span class="comment">// 属性后面的?表示该属性为可选属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> Cooper: IPerson = &#123;</span><br><span class="line">	name: <span class="string">'Cooper'</span></span><br><span class="line">&#125;<span class="comment">//这里没有赋值可选属性age</span></span><br></pre></td></tr></table></figure></li>
<li>任意属性<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson&#123;</span><br><span class="line">	name: <span class="built_in">string</span>;</span><br><span class="line">	age?: <span class="built_in">string</span>;</span><br><span class="line">	[propName: <span class="built_in">string</span>]: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cooper: IPerson = &#123;</span><br><span class="line">	name: <span class="string">'Cooper'</span>,</span><br><span class="line">	gender: <span class="string">'male'</span> <span class="comment">//添加的任意属性gender</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>一旦定义了任意类型，那么确认属性和可选的属性的类型必须是任意属性类型的子类，也就是说，上例中age的属性必须是定义的任意类型的其中之一</strong></p>
<ul>
<li>如下<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IPerson&#123;</span><br><span class="line">	name: <span class="built_in">string</span>;</span><br><span class="line">	age?: <span class="built_in">number</span>;</span><br><span class="line">	[propName: <span class="built_in">string</span>]: <span class="built_in">string</span> | <span class="built_in">number</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>只读属性，即只允许在初始化时被赋值，后续不允许修改的属性，使用<code>readonly</code>关键字来定义<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">interfce IPerson&#123;</span><br><span class="line">	readonly id: <span class="built_in">number</span>;</span><br><span class="line">	name: <span class="built_in">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> cooper: IPerson = &#123;</span><br><span class="line">	id: <span class="number">123</span>,</span><br><span class="line">	name: <span class="string">'Cooper'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="数组的类型定义"><a href="#数组的类型定义" class="headerlink" title="数组的类型定义"></a>数组的类型定义</h2><ul>
<li>类型+中括号<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">number</span>[] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure></li>
<li>数组泛型， Array[T], T为泛型<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> list: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br></pre></td></tr></table></figure></li>
<li>用接口表示<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> INumberArray&#123;</span><br><span class="line">	[index: <span class="built_in">number</span>]: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> list: INumberArray = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure></li>
<li>对象数组的定义<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IIterm = &#123;</span><br><span class="line">	name: <span class="built_in">string</span>,</span><br><span class="line">	age: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> list: IIterm[] = [</span><br><span class="line">	&#123;</span><br><span class="line">		name: <span class="string">'Cooper'</span>,</span><br><span class="line">		age: <span class="number">23</span></span><br><span class="line">	&#125;,</span><br><span class="line">	&#123;</span><br><span class="line">		name: <span class="string">'Bob'</span>,</span><br><span class="line">		age: <span class="number">23</span></span><br><span class="line">	&#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h2><ul>
<li>函数的声明方式<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//函数式声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数表达式</span></span><br><span class="line"><span class="keyword">const</span> mySun = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>函数式声明定义类型<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//明确了接受的两个参数和返回值必须为number</span></span><br></pre></td></tr></table></figure></li>
<li>函数表达式定义类型<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> myFun: <span class="function">(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) =&gt;</span> <span class="built_in">number</span> = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span>  x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//左侧变量类型可以省略</span></span><br><span class="line"><span class="keyword">let</span> myFun = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用接口定义<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> IMyFun&#123;</span><br><span class="line">	(x:  <span class="built_in">number</span>, y: <span class="built_in">number</span>): <span class="built_in">boolean</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myFun: iMyFun = <span class="function"><span class="keyword">function</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">boolean</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>可选参数和剩余参数<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//y作为可选参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">number</span>, y?:<span class="built_in">number</span></span>): <span class="title">number</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(y)&#123;</span><br><span class="line">		<span class="keyword">return</span> x + y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//剩余参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">number</span>, ...ars: <span class="built_in">any</span>[]</span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line">myFun(<span class="number">1</span>, <span class="number">2</span>, <span class="string">'3'</span>);<span class="comment">//输出的结果为[2, '3']</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>类型断言即手动指定一个变量的类型</p>
<ul>
<li>语法<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;类型&gt;变量</span><br><span class="line">变量 as 类型</span><br></pre></td></tr></table></figure></li>
<li>例子<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">number</span> | <span class="built_in">string</span></span>)</span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(&lt;<span class="built_in">string</span>&gt;x. length);<span class="comment">//这里通过类型断言指定x的属性为string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>特殊，当我们声明可选参数时，我们需要先判断参数存在才能使用<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>): <span class="title">number</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(y)&#123;</span><br><span class="line">		<span class="keyword">const</span> result = x + y; <span class="comment">//不进行判断将会报错</span></span><br><span class="line">		<span class="keyword">return</span> reuslt;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//或者通过断言</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFun</span>(<span class="params">x: <span class="built_in">number</span>, y?: <span class="built_in">number</span></span>): <span class="title">number</span></span>&#123;</span><br><span class="line">	<span class="keyword">const</span> result = x + !y; <span class="comment">//!表示该变量一定存在</span></span><br><span class="line">	<span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><p>对于一些常用的第三方模块，只要在使用npm安装的时候， 在模块名前面加上@type/</p>
<blockquote>
<p>npm install @/types/express –save-dev</p>
</blockquote>
<p>对于不常用的第三方模块，在typescript社区中无法安装带有声明文件的模块，我们可以在项目的根目录下创建一个index.d.ts文件，在其中对其进行声明，防止ts报错。</p>
<blockquote>
<p> declare module ‘so-utils’;//声明so-utils为一个模块，防止import * from ‘so-utils’报错</p>
</blockquote>
<hr>
<h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><p>JavaScript中定义好的对象，可以当作定义好的类型来使用</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> bodyDoc: HTMLDocument = <span class="built_in">document</span>.body</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h2><p>使用<code>type</code>关键字来声明类型的别名</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Name = <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameResolver = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">string</span>;</span><br><span class="line"><span class="keyword">type</span> NameOrResolver = Name | NameResolver</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params">n: NameOrResolver</span>): <span class="title">Name</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">typeof</span> n === <span class="string">'string'</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> n;</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> n();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="字符串字面量类型"><a href="#字符串字面量类型" class="headerlink" title="字符串字面量类型"></a>字符串字面量类型</h2><p>字符串字面量类型用来约束取值只能是某几个字符串取值中的一个</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> eventName = <span class="string">'click'</span> | <span class="string">'scroll'</span> | <span class="string">'mousemove'</span></span><br><span class="line"><span class="comment">//第二个参数event只能是‘click’｜‘scroll’｜‘mousemove’三个中的某一个</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleEvent</span>(<span class="params">ele: Element, event: eventName</span>)</span>&#123;</span><br><span class="line">	<span class="comment">//event</span></span><br><span class="line">&#125;</span><br><span class="line">handleEvent(<span class="built_in">document</span>.getElementById(<span class="string">'hello'</span>), <span class="string">'scroll'</span>);</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
</search>
